export const meta = {
  title: "Wzorzec: Command design pattern",
  seo_desc:
    "Command design pattern, zwany rÃ³wnieÅ¼ wzorcem 'polecenia' pozwala nam na oddzielenie od siebie obiektÃ³w nadawcy oraz odbiorcy.",
  short:
    "W tym artykule zapoznasz siÄ™ z wzorcem projektowym Command. PrzybliÅ¼ymy jego zastosowanie przez analogiÄ™ do Å›wiata kulinarnego, a potem przejdziemy do praktycznej implementacji w JavaScript i TypeScript. Idealne dla osÃ³b szukajÄ…cych sposobÃ³w na poprawÄ™ moduÅ‚owoÅ›ci kodu.",
  date: "2021-07-19",
  tags: ["Wzorce", "JavaScript"],
};

Kolejnym wzorcem projektowym na naszej liÅ›cie jest Command design pattern, nazywany rÃ³wnieÅ¼ po prostu â€Poleceniemâ€. Wzorzec ten jest przydatny w sytuacji, gdy chcemy oddzieliÄ‡ obiekty wydajÄ…ce polecenia od obiektÃ³w, ktÃ³re te polecenia bÄ™dÄ… wykonywaÄ‡. WyobraÅºmy sobie scenariusz, gdzie nasza aplikacja korzysta z duÅ¼ej liczby wywoÅ‚aÅ„ API do jakiegoÅ› konkretnego serwisu. Co w przypadku gdy serwis ten zmieni swoje gÅ‚Ã³wne API albo bÄ™dziemy chcieli wymieniÄ‡ ten serwis na jakiÅ› inny? Musimy oczywiÅ›cie zmodyfikowaÄ‡ kod wszÄ™dzie tam, gdzie â€uderzaliÅ›myâ€ do serwisu przed zmianami. Nie brzmi ciekawie, prawda? Zobaczmy jak moÅ¼e nam w tej sytuacji pomÃ³c Command design patter.

Zanim wrÃ³cimy do wspomnianego juÅ¼ przykÅ‚adu z API, sprÃ³bujmy sobie jeszcze bardziej doprecyzowaÄ‡, na czym polega omawiany tutaj wzorzec. W tym celu odejdziemy na chwilÄ™ od programowania i przeniesiemy siÄ™ w Å›wiat kulinarny.

## Pad Thai ğŸœ

WyobraÅºmy sobie sytuacjÄ™, w ktÃ³rej regularnie odwiedzamy naszÄ… ulubionÄ… knajpkÄ™ z tajskim jedzeniem. Zazwyczaj zamawiamy tam Pad Thaia oraz sok z mango. W tym przypadku my jako klient niejako wydajemy polecenie â€przygotuj mi Pad Thaia i podaj mi sokâ€. JeÅ¼eli lokal jest naprawdÄ™ bardzo maÅ‚y, byÄ‡ moÅ¼e nasze zamÃ³wienie (polecenie) przyjmie od nas razu kucharz. De facto to on jest odbiorcÄ… polecenia, poniewaÅ¼ to on ma wiedzÄ™ oraz umiejÄ™tnoÅ›ci w zakresie przygotowania naszego dania.

Mocno teraz naginajÄ…c nasz przykÅ‚ad, zaÅ‚Ã³Å¼my, Å¼e ktÃ³rego dnia w tej samej restauracji znajduje siÄ™ juÅ¼ inny kucharz i nie mÃ³wi on w naszym jÄ™zyku, albo gotuje w innym pomieszczeniu i nie wiem w ktÃ³rym, bÄ…dÅº teÅ¼ nowy kucharz nie wie, gdzie znajduje siÄ™ sok i nie moÅ¼e nam go wydaÄ‡? Sprawa trochÄ™ siÄ™ skomplikuje a my albo bÄ™dziemy musieli skorzystaÄ‡ z tÅ‚umacza, poszukaÄ‡ nowego pomieszczenia, albo pogodziÄ‡ siÄ™ z myÅ›lÄ…, Å¼e zamiast soku z mango otrzymamy np. wodÄ™. Musimy zmieniÄ‡ nasze dotychczasowe zachowanie, aby w dalszym ciÄ…gu otrzymaÄ‡ posiÅ‚ek.

Sytuacja wyglÄ…daÅ‚a zupeÅ‚nie inaczej, gdyby w takiej restauracji pracowaÅ‚ dodatkowo kelner. ByÅ‚by on Å‚Ä…cznikiem na linii klient â†” kucharz. Kelner przyjmuje polecenie i wie, w jaki sposÃ³b ma je dostarczyÄ‡ do osoby umiejÄ…cej to polecenie wykonaÄ‡. W przypadku zmiany kucharza, to kelner wyposaÅ¼y siÄ™ w tÅ‚umacza i dowie siÄ™, gdzie teraz naleÅ¼y zanosiÄ‡ zamÃ³wienia. OprÃ³cz tego bÄ™dzie w stanie samodzielnie wykonywaÄ‡ bardzo proste czynnoÅ›ci, takie jak np. podanie soku. My nasze zamÃ³wienia bÄ™dziemy skÅ‚adaÄ‡ tak jak zawsze â€“ nie odnotujemy zmian, ktÃ³re wydarzyÅ‚y siÄ™ "za kulisami".

<img src="/blog/command-design-pattern/padthai.gif" />

Widzimy tutaj, iÅ¼ wprowadzajÄ…c kelnera, odseparowaliÅ›my od siebie nadawcÄ™ oraz wykonawcÄ™ polecenia. Tego typu zabieg jest jednak doÅ›Ä‡ kosztowny. W przypadku kelnera bÄ™dzie to jego pensja, natomiast w programowaniu bÄ™dzie to dodatkowy narzut w postaci kodu, zuÅ¼ycia procesora oraz czytelnoÅ›ci (dodatkowa warstwa abstrakcji / komunikacji).

## Wracamy do kodu

Nie wiem jak wy, ale ja po opisaniu tego przykÅ‚adu musiaÅ‚em wstaÄ‡ i wyjÅ›Ä‡ coÅ› zjeÅ›Ä‡â€¦ chyba nie muszÄ™ mÃ³wiÄ‡ co ğŸ˜‰. Wracamy jednak juÅ¼ teraz do kodu i zamieniamy paÅ‚eczki na klawiaturÄ™. Jak widzieliÅ›my w przykÅ‚adzie, w przypadku wzorca command design pattern najczÄ™Å›ciej bÄ™dziemy mieli do czynienia z czterema elementami:

- **klient** (client) â€“ obiekt wydajÄ…cy polecenie,
- **polecenie** (command) â€“ obiekt zawierajÄ…cy informacjÄ™ na temat akcji, ktÃ³ra ma zostaÄ‡ podjÄ™ta/wykonana,
- **posÅ‚aniec** (invoker) â€“ poÅ›rednik pomiÄ™dzy klientem a wykonawcÄ…,
- **wykonawca** (receiver) â€“ obiekt wykonujÄ…cy akcje zawarte w poleceniu.

Mam nadziejÄ™, Å¼e juÅ¼ mniej wiÄ™cej rozumiemy istotÄ™ tego wzorca, zobaczmy wiÄ™c teraz, jak moÅ¼e wyglÄ…daÄ‡ przykÅ‚adowa implementacja tego, o czym do tej pory mÃ³wiliÅ›my za pomocÄ… JavaScript.

## PrzykÅ‚ad nr 1 (trochÄ™ Å‚atwiejszy)

W pierwszym przykÅ‚adzie moÅ¼emy zobaczyÄ‡, w jaki sposÃ³b moÅ¼emy wprowadziÄ‡ dodatkowÄ… warstwÄ™ poÅ›redniczÄ…cÄ… w wywoÅ‚aniu prostych metod umieszczonych wewnÄ…trz obiektu:

```js
/* Obiekt, kÃ³ry wie jak wykonywaÄ‡ polecenia.
Z prostymi zadaniami poradzi sobie sam, trudniejsze deleguje
do odpwiedniego serwisu. */

const operations = {
  add: (x, y) => x + y,
  subtract: (x, y) => x - y,
  heavyMath: (x, y) => Math.sin(x) / Math.tan(y),
};

/* Obiekt, ktÃ³ry jest uÅ¼ywany jako warstwa abstrakcji
podczas wykonywania poleceÅ„. Reprezentuje interfejs w
kierunku obiektu wywoÅ‚ujÄ…cego. */
const mathManager = {
  /* CzÄ™sto spotykanÄ… praktykÄ… jest nazywanie metody wywoÅ‚ujÄ…cej
  jako "execute" */
  execute: function (name, args) {
    if (name in operations) {
      /* Odnosimy siÄ™ do obiektu wywoÅ‚ujÄ…cego poprzez
      wywoÅ‚ywanie zdefiniowanych na nim metod i przekazanie do nich
      odpowiednich parametrÃ³w. */
      return operations[name].apply(operations, [].slice.call(arguments, 1));
    }
    return console.log("ğŸ¤·â€");
  },
};

/* MoÅ¼emy oczywiÅ›cie omijaÄ‡ warstwÄ™ abstrakcji i wywoÅ‚ywaÄ‡ 
polecenia bezpoÅ›rednio z obiektu "operations": */
console.log(operations.add(2, 3)); // => 5
console.log(operations.subtract(2, 3)); // => -1

/* MoÅ¼emy jednak skorzystaÄ‡ z mathManagera, wysÅ‚aÄ‡ do niego
odpowiedniÄ… komendÄ™ i czekaÄ‡ na rezultat: */
console.log(mathManager.execute("add", 2, 3)); // => 5
console.log(mathManager.execute("subtract", 2, 3)); // => -1
console.log(mathManager.execute("heavyMath", 2, 3)); // => -6,379
console.log(mathManager.execute("multiply", 2, 3)); // => ğŸ¤·â€
```

## PrzykÅ‚ad nr 2 (TypeScript oraz klasy)

W drugim przykÅ‚adzie posÅ‚uÅ¼ymy siÄ™ juÅ¼ klasami. SprÃ³bujemy tutaj odwzorowaÄ‡ to, o czym powiedzieliÅ›my sobie w przykÅ‚adzie z restauracjÄ…. Dodatkowo juÅ¼ bardzo wyraÅºnie zaznaczymy ktÃ³ra klasa peÅ‚ni funkcjÄ™ polecenia, posÅ‚aÅ„ca, wykonawcy oraz klienta.

```ts
/**
 * Interfejs polecenia. Tak jak wspomniaÅ‚em juÅ¼ we wczeÅ›niejszym
 * przykÅ‚adzie, metodÄ™ wywoÅ‚ujÄ…cÄ… polecenie zazwyczaj nazywamy "execute".
 */
interface Command {
  execute(): void;
}

/**
 * Proste polecenie nie musi wymagaÄ‡ odwoÅ‚aÅ„ do zewnÄ™trznych serwisÃ³w i
 * moÅ¼e byÄ‡ bezpoÅ›rednio obsÅ‚uÅ¼one.
 */
class OrderDrik implements Command {
  private drinkName: string;

  constructor(drinkName: string) {
    this.drinkName = drinkName;
  }

  public execute() {
    console.log(`Here is your ${this.drinkName} drink`);
  }
}

/**
 * Bardziej skomplikowane polecenia mogÄ… odwoÅ‚ywaÄ‡ siÄ™ do zewnÄ™trznych
 * serwisÃ³w, tzw. odbiorcÃ³w. To do nich zostanie przesÅ‚ane polecenie.
 */
class OrderFood implements Command {
  private receiver: Receiver;
  private meal: string;

  /**
   * OdbiorcÄ™ polecenia moÅ¼emy przekazaÄ‡ podczas tworzenia klasy, wtedy
   * nasz kod bÄ™dzie bardziej uniwersalny.
   */
  constructor(receiver: Receiver, meal: string) {
    this.receiver = receiver;
    this.meal = meal;
  }

  /**
   * WywoÅ‚anie metody dostÄ™pnej na odbiorcy i przekazanie ewentualnych
   * parametrÃ³w.
   */
  public execute() {
    this.receiver.cookMeal(this.meal);
  }
}

/**
 * Odbiorca ma wiedzÄ™ o tym jak poradziÄ‡ sobie z danym poleceniem.
 * Tutaj rÃ³wnieÅ¼ czÄ™sto trafia logika biznesowa.
 */
class Receiver {
  public cookMeal(meal: string): void {
    console.log(`Creating a ${meal} for you!`);
  }
}

/**
 * PoÅ›rednik wywoÅ‚ujÄ…cy metody moÅ¼e byÄ‡ w stanie obsÅ‚ugiwaÄ‡
 * wiele rÃ³Å¼nych poleceÅ„.
 */
class Invoker {
  /**
   * Invoker nie jest zaleÅ¼ny ani od polecenia ani od wykonawcy.
   * Przekazuje on jedynie polecenie do odbiorcy (poprzez wywoÅ‚anie metody).
   */
  public takeMealOrder(order: OrderFood): void {
    order.execute();
  }

  public takeDrinkOrder(order: OrderDrik): void {
    order.execute();
  }
}

/**
 * Klient "wydajÄ…c" polecenie komunikuje siÄ™ jedynie z poÅ›rednikiem.
 */
class Client {
  private invoker: Invoker;
  private receiver: Receiver;

  constructor(invoker: Invoker, receiver: Receiver) {
    this.invoker = invoker;
    this.receiver = receiver;
  }

  makeOrder(meal?: string, drink?: string) {
    if (meal) {
      const orderFood = new OrderFood(this.receiver, meal);
      this.invoker.takeMealOrder(orderFood);
    }

    if (drink) {
      const orderDrink = new OrderDrik(drink);
      this.invoker.takeDrinkOrder(orderDrink);
    }
  }
}

/**
 * Wydanie polecenia (zÅ‚oÅ¼enie zamÃ³wienia) przez klienta:
 */
const invoker = new Invoker();
const receiver = new Receiver();

const client = new Client(invoker, receiver);

client.makeOrder("Pad Thai", "Mango Juice");
client.makeOrder("Curry Soup");
client.makeOrder(undefined, "Coke");

/**
 * Output:
 * "Creating a Pad Thai for you!"
 * "Here is your Mango Juice drink"
 * "Creating a Curry Soup for you!"
 * "Here is your Coke drink"
 */
```

## Wady i ograniczenia

Pomimo wielu zalet wzorca Command, istniejÄ… rÃ³wnieÅ¼ pewne wady i ograniczenia, ktÃ³re warto rozwaÅ¼yÄ‡ przed jego zastosowaniem:

- **ZÅ‚oÅ¼onoÅ›Ä‡ kodu:** Jak zostaÅ‚o to juÅ¼ wczeÅ›niej wspomniane, wzorzec Command dodaje dodatkowÄ… warstwÄ™ abstrakcji do struktury kodu. W rezultacie, moÅ¼e to prowadziÄ‡ do zwiÄ™kszonej zÅ‚oÅ¼onoÅ›ci, szczegÃ³lnie w przypadku prostych aplikacji, gdzie taka abstrakcja moÅ¼e byÄ‡ zbÄ™dna.
- **Wymagania dotyczÄ…ce pamiÄ™ci:** Ze wzglÄ™du na swojÄ… naturÄ™, wzorzec Command moÅ¼e wymagaÄ‡ wiÄ™cej pamiÄ™ci operacyjnej. Dzieje siÄ™ tak, poniewaÅ¼ kaÅ¼de polecenie jest reprezentowane przez dedykowany obiekt, ktÃ³ry musi byÄ‡ przechowywany do momentu jego wykonania. MoÅ¼e to byÄ‡ problematyczne w przypadku systemÃ³w o ograniczonych zasobach pamiÄ™ci, szczegÃ³lnie jeÅ›li sÄ… one zobowiÄ…zane do obsÅ‚ugi duÅ¼ej liczby poleceÅ„.
- **TrudnoÅ›Ä‡ w utrzymaniu:** Wraz ze wzrostem liczby poleceÅ„, utrzymanie kodu moÅ¼e staÄ‡ siÄ™ bardziej skomplikowane. KaÅ¼de polecenie to osobna klasa, ktÃ³ra musi byÄ‡ utrzymywana i ewentualnie modyfikowana w miarÄ™ ewolucji projektu.
- **Skomplikowane testowanie:** Ze wzglÄ™du na dodatkowÄ… warstwÄ™ abstrakcji, testowanie kodu korzystajÄ…cego z wzorca Command moÅ¼e byÄ‡ bardziej skomplikowane. KaÅ¼de polecenie musi byÄ‡ testowane osobno, a nastÄ™pnie w kontekÅ›cie interakcji z innymi obiektami.

## Command design pattern â€“ podsumowanie

Za pomocÄ… wzorca Command design pattern moÅ¼emy relatywnie Å‚atwo oddzieliÄ‡ od siebie klasy (obiekty), wywoÅ‚ujÄ…ce polecenia od obiektÃ³w wykonawczych. DziÄ™ki temu nasz kod stanie bardziej modularny i speÅ‚nimy zasady pojedynczej odpowiedzialnoÅ›ci. Taki kod bÄ™dzie w przyszÅ‚oÅ›ci duÅ¼o Å‚atwiejszy do utrzymania w trakcie poprawek, dodawania nowych poleceÅ„ lub podmiany caÅ‚ych serwisÃ³w.

WadÄ… tego rozwiÄ…zania z pewnoÅ›ciÄ… jest komplikacja kodu, gdyÅ¼ wprowadzamy caÅ‚Ä… nowÄ… warstwÄ™ pomiÄ™dzy dwa komunikujÄ…ce siÄ™ ze sobÄ… obiekty. W przypadku prostych poleceÅ„, ktÃ³re nie wymagajÄ… odwoÅ‚aÅ„ do zewnÄ™trznych serwisÃ³w, nie ma sensu stosowaÄ‡ tego wzorca. W przypadku bardziej skomplikowanych poleceÅ„, ktÃ³re wymagajÄ… odwoÅ‚aÅ„ do zewnÄ™trznych serwisÃ³w, wzorzec ten moÅ¼e okazaÄ‡ siÄ™ bardzo przydatny.
