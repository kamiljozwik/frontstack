<section>
## `infer` - zaawansowany typ warunkowy w TS

<small>ğŸ“… 07.06.2023</small>

W TypeScript moÅ¼emy wykorzystaÄ‡ typy warunkowe wraz z sÅ‚owem kluczowym `infer` do wnioskowania o typach. Przyjrzyjmy siÄ™ poniÅ¼szemu przykÅ‚adowi:

```typescript
type ArrayTypes<T> = T extends (infer U)[] ? U : never;

let arr = [1, "2", []];
type test = ArrayTypes<typeof arr>; // typ test = string | number | any[]
```

W tym przykÅ‚adzie, typ `ArrayTypes<T>` bierze typ `T` i sprawdza, czy `T` jest typem tablicy. JeÅ›li tak, to inferuje typ `U` z tablicy `T[]` i zwraca `U`. W przeciwnym razie zwraca `never`.

WaÅ¼ne jest, aby zauwaÅ¼yÄ‡, Å¼e `infer` musi byÄ‡ podÅ‚Ä…czony do `U`, a nie do `[]`. Dlatego korzystamy z nawiasÃ³w w `(infer U)[]`. Bez nawiasÃ³w, TypeScript zinterpretowaÅ‚by to jako `infer (U[])`, co byÅ‚oby niepoprawne, poniewaÅ¼ `infer` moÅ¼e byÄ‡ uÅ¼ywane tylko do inferencji typÃ³w, a nie struktur typÃ³w takich jak tabliceã€33â€ sourceã€‘.

Kolejny przykÅ‚ad, tym razem z obiektem. W tym przypadku `infer` stworzy nam typ, ktÃ³ry bÄ™dzie zawieraÅ‚ wszystkie typy wartoÅ›ci obiektu:

```typescript
type ObjectTypes<T> = T extends { a: infer U; b: infer U } ? U : never;

let obj = { a: 1, b: "2" };
type Test = ObjectTypes<typeof obj>; // typ Test = string | number
```

Jak widaÄ‡ moÅ¼liwoÅ›ci tutaj sÄ… ogromne, wiÄ™c warto zapoznaÄ‡ siÄ™ z tym tematem.

</section>

<section>
## Typy warunkowe w TypeScript

<small>ğŸ“… 07.06.2023</small>

Typy warunkowe w TypeScript pozwalajÄ… na wybÃ³r typu w zaleÅ¼noÅ›ci od warunku. Jest to doÅ›Ä‡ przydatne narzÄ™dzie, ktÃ³re pozwala na tworzenie bardziej zÅ‚oÅ¼onych typÃ³w.

```typescript
type IsString<T> = T extends string ? true : false;

type X = IsString<"hello">; // true
type Y = IsString<number>; // false
type Z = IsString<{ name: string }>; // false
```

W tym prostym przykÅ‚adzie, `IsString` jest typem warunkowym, ktÃ³ry sprawdza, czy podany typ `T` jest stringiem. JeÅ›li tak, to zwraca `true`, a w przeciwnym razie zwraca `false`.

PamiÄ™taj, Å¼e typy warunkowe mogÄ… byÄ‡ zagnieÅ¼dÅ¼one i mogÄ… uÅ¼ywaÄ‡ dowolnej logiki (moÅ¼emy np. uÅ¼ywaÄ‡ tego sprawdzenia w `if`-ach i zawÄ™Å¼aÄ‡ bardziej typowanie), ktÃ³ra jest dostÄ™pna w typach, co czyni je niezwykle elastycznymi i potÄ™Å¼nymi narzÄ™dziami do modelowania typÃ³w w TypeScript.

</section>

<section>
## `unknown` vs `any` w TS

<small>ğŸ“… 05.06.2023</small>

W TypeScript typ `unknown` jest bezpieczniejszym odpowiednikiem typu `any`. Podczas gdy `any` pozwala nam na wszystko, `unknown` wymusza sprawdzanie typu przed wykonaniem operacji.

```ts
let foo: any = "hello";
foo = foo.split("").reverse().join(""); // ZadziaÅ‚a, ale...

let foo2: any = { greet: "hello" };
foo2 = foo.split("").reverse().join(""); // TS nie wykryje bÅ‚Ä™du, ale dostaniemy bÅ‚Ä…d w konsoli

let bar: unknown = "world";
bar = bar.split("").reverse().join(""); // TS podkreÅ›li nam bÅ‚Ä…d w edytorze, poniewaÅ¼ nie moÅ¼emy uÅ¼yÄ‡ metody "split" na nieznanym typie.

bar = (bar as string).split("").reverse().join(""); // OK, poniewaÅ¼ zadeklarowaliÅ›my typ, ale moÅ¼e byÄ‡ lepiej...
bar = typeof bar === "string" ? bar.split("").reverse().join("") : bar; // Jeszcze lepiej, poniewaÅ¼ sprawdziliÅ›my typ
```

Z `unknown` TypeScript zapewnia, Å¼e musiz sprawdziÄ‡ typ przed wykonaniem operacji, wiÄ™c jest to duÅ¼o bezpieczniejsze podejÅ›cie niÅ¼ `any`.

</section>

<section>
## Aliasy podczas importÃ³w w TS

<small>ğŸ“… 05.06.2023</small>

Macie juÅ¼ doÅ›Ä‡ _kropkowania_ podczas importÃ³w? [Aliasy](https://www.typescriptlang.org/tsconfig#paths) w TS mogÄ… nam tutaj znacznie uproÅ›ciÄ‡ Å¼ycie. Do pliku `tsconfig.json` wystarczy dodaÄ‡ nastÄ™pujÄ…cÄ… konfiguracjÄ™:

```json title="tsconfig.json"
{
  "compilerOptions": {
    // Your other options...
    "paths": {
      "@/*": ["./src/*"]
    }
  }
}
```

Od teraz moÅ¼emy zaczynaÄ‡ nasze importy od zdefiniowanego wczeÅ›niej poziomu w naszej aplikacji:

```ts
import { Button } from "@/components/Button"; // ğŸ¤© import z "src/components/Button"
import { OtherButton } from "../../../components/Button"; // ğŸ˜¥
```

Taka skÅ‚adnia jest duÅ¼o czytelniejsza i Å‚atwiejsza do utrzymania. JeÅ›li zmienimy zagnieÅ¼dÅ¼enie bÄ…dÅº poÅ‚oÅ¼enie folderu, to nie musimy martwiÄ‡ siÄ™ o zmianÄ™ Å›cieÅ¼ek w naszym kodzie ğŸ’ª.

</section>

<section>
## WartoÅ›Ä‡ domyÅ›lna dla kaÅ¼dego klucza w obiekcie

<small>ğŸ“… 04.06.2023</small>

Czasami chcemy (niezbyt czÄ™sto, ale moÅ¼e siÄ™ zdarzyÄ‡ ğŸ˜‰), aby wÅ‚aÅ›ciwoÅ›ci obiektu byÅ‚y automatycznie inicjalizowane. Powszechnym sposobem radzenia sobie z tym jest korzystanie z metod `getter` i `setter`. Jednak moÅ¼e to staÄ‡ siÄ™ uciÄ…Å¼liwe, jeÅ›li mamy wiele wÅ‚aÅ›ciwoÅ›ci. WÅ‚aÅ›nie tutaj obiekt [Proxy](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy?retiredLocale=pl) moÅ¼e okazaÄ‡ siÄ™ bardzo pomocny.

`Proxy` w JavaScript jest uÅ¼ywane do definiowania niestandardowego zachowania dla podstawowych operacji (np. wyszukiwanie, przypisanie, wyliczanie, wywoÅ‚ywanie funkcji itp.) obiektÃ³w.

Proxy moÅ¼emy rÃ³wnieÅ¼ uÅ¼yÄ‡ wiÄ™c rÃ³wnieÅ¼ do automatycznego inicjowania wÅ‚aÅ›ciwoÅ›ci obiektÃ³w, ktÃ³rych wÅ‚aÅ›ciwoÅ›ci nie sÄ… do koÅ„ca znane:

```js
const autoInit = (defaultValue) =>
  new Proxy(
    {},
    {
      get: (target, name) =>
        name in target ? target[name] : (target[name] = defaultValue),
    }
  );

const myObject = autoInit([]);

console.log(myObject.foo); // []

myObject.foo.push("bar");

console.log(myObject.foo); // ['bar']
```

W tym przykÅ‚adzie kaÅ¼da wÅ‚aÅ›ciwoÅ›Ä‡ `myObject`, ktÃ³ra jest dostÄ™pna przed jej ustawieniem, zostanie automatycznie zainicjowana na pustÄ… tablicÄ™ (lub dowolnÄ… innÄ… domyÅ›lnÄ… wartoÅ›Ä‡, ktÃ³rÄ… podamy). MoÅ¼e to byÄ‡ doÅ›Ä‡ przydatne w sytuacjach w ktÃ³rych chcemy uniknÄ…Ä‡ wartoÅ›ci `undefined`.

</section>

<section>
## Szybkie sprawdzanie wÅ‚aÅ›ciwoÅ›ci obiektu w JavaScript

<small>ğŸ“… 04.06.2023</small>

Czy wiedziaÅ‚eÅ›, Å¼e moÅ¼esz sprawdziÄ‡, czy obiekt ma danÄ… wÅ‚aÅ›ciwoÅ›Ä‡ uÅ¼ywajÄ…c operatora `in`? Oto jak to zrobiÄ‡:

```javascript
const myObject = { foo: "bar" };

console.log("foo" in myObject); // true
console.log("baz" in myObject); // false
```

Szybko i czysto, bez potrzeby sprawdzania `undefined` ğŸ˜‰

</section>

<section>
## Readonly w TS

<small>ğŸ“… 30.05.2023</small>

W jÄ™zyku TypeScript moÅ¼na uÅ¼yÄ‡ modyfikatora `readonly`, aby wskazaÄ‡, Å¼e wÅ‚aÅ›ciwoÅ›Ä‡ klasy lub interfejsu jest tylko do odczytu, co oznacza, Å¼e po przypisaniu do niej wartoÅ›ci nie moÅ¼na jej zmieniÄ‡. Oto krÃ³tki przykÅ‚ad:

```ts
interface Point {
  readonly x: number;
  readonly y: number;
}

let p: Point = { x: 10, y: 20 };
p.x = 5; // Error: Cannot assign to 'x' because it is a read-only property
```

W powyÅ¼szym kodzie `x` i `y` w `Point` sÄ… wÅ‚aÅ›ciwoÅ›ciami tylko do odczytu ğŸ’ª.

</section>

<section>
## Brak mockÃ³w w testach z `React Router (v6)` i `React Testing Library`

<small>ğŸ“… 29.05.2023</small>

Customowy `render()`, za pomocÄ… ktÃ³rego moÅ¼emy Å‚atwo testowaÄ‡ komponenty wykorzystujÄ…ce nawigacjÄ™ w naszej aplikacji:

```js
import React, { isValidElement } from "react";
import { render } from "@testing-library/react";
import { RouterProvider, createMemoryRouter } from "react-router-dom";

export function renderWithRouter(children, routes = []) {
  const options = isValidElement(children)
    ? { element: children, path: "/" }
    : children;

  const router = createMemoryRouter([{ ...options }, ...routes], {
    initialEntries: [options.path],
    initialIndex: 1,
  });

  return render(<RouterProvider router={router} />);
}
```

DokÅ‚adniejsze omÃ³wienie powyÅ¼szego kodu oraz przykÅ‚adowe uÅ¼ycie do znalezienia w [tym artykule](https://webup.org/blog/how-to-avoid-mocking-in-react-router-v6-tests/).

</section>

<section>
## TS `type guards` dla tablic danych

<small>ğŸ“… 28.05.2023</small>

CoÅ› czego moÅ¼e nie nauczyÅ‚em siÄ™ dzisiaj, ale ostatnio potrzebowaÅ‚em z tego skorzystaÄ‡ i musiaÅ‚em wrÃ³ciÄ‡ do dokumentacji, Å¼eby sobie nieco ten temat przypomnieÄ‡.

JeÅ›li mamy tablicÄ™ danych, ktÃ³ra moÅ¼e zawieraÄ‡ rÃ³Å¼ne typy (czyli np. nie jesteÅ›my pewni odpowiedzi z API), to moÅ¼emy uÅ¼yÄ‡ [type guard](https://www.typescriptlang.org/docs/handbook/2/narrowing.html#using-type-predicates) i metodÄ™ `.every()` zamiast `if-Ã³w`, Å¼eby zawÄ™ziÄ‡ sobie typowanie.

```ts
// type guard z uÅ¼yciem sÅ‚owa kluczowego "is"
function isArrayOfNumbers(arr: unknown[]): arr is number[] {
  return arr.every((element) => typeof element === "number");
}

const arr = [1, 2, 3, 4, 5];

if (isArrayOfNumbers(arr)) {
  console.log(arr[0].toFixed); // âœ… OK, wiemy, Å¼e "arr" jest tablicÄ… liczb
} else {
  console.log(arr[0].toFixed); // â›” ERROR, nie moÅ¼emy uÅ¼yÄ‡ metody ".toFixed()" na typie "unknown"
}
```

PowyÅ¼ej mamy prosty przykÅ‚ad z tablicÄ… liczb, ale moÅ¼emy teÅ¼ uÅ¼yÄ‡ tego rozwiÄ…zania do bardziej skomplikowanych typÃ³w danych.

</section>
