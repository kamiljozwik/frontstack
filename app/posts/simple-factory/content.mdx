export const meta = {
  title: "Wzorzec: Simple Factory",
  seo_desc:
    "Wzorzec projektowy Simple Factory (nazywany rÃ³wnieÅ¼ po prostu FabrykÄ…) to jeden z podstawowych wzorcÃ³w w jÄ™zyku JavaScript.",
  short:
    "Wzorzec projektowy Simple Factory (nazywany rÃ³wnieÅ¼ po prostu FabrykÄ…) to jeden z podstawowych wzorcÃ³w w jÄ™zyku JavaScript. W tym krÃ³kim wpisie dowiesz siÄ™ czym jest i jak go uÅ¼ywaÄ‡. Zobaczysz rÃ³wnieÅ¼ dwa przykÅ‚ady i dowiesz siÄ™ jakie problemy ten wzorzec rozwiÄ…zuje.",
  date: "2021-03-16",
  tags: ["JavaScript", "Wzorce"],
};

Wzorzec Simple Factory, czÄ™sto nazywany rÃ³wnieÅ¼ po prostu â€FabrykÄ…â€ jest jednym z podstawowych wzorcÃ³w projektowych uÅ¼ywanych w JavaScript. Jest bardzo prosty w uÅ¼yciu, wiÄ™c ten krÃ³tki post nie powinien byÄ‡ dla nikogo problematyczny ğŸ™‚

<img src="/blog/simple-factory/factory.gif" />

## Czemu "Fabryka"?

GÅ‚Ã³wnym celem stosowania tego wzorca jest â€produkowanieâ€ obiektÃ³w zwiÄ…zanych z jednym wspÃ³lnym interfejsem. UÅ¼ywajÄ…c â€Fabrykiâ€ w kodzie nie interesuje nas za bardzo, w jaki sposÃ³b ten obiekt zostanie stworzony. My jedynie podajemy â€parametryâ€ i oczekujemy na dostarczenie prawidÅ‚owo â€wyprodukowanegoâ€ obiektu.

Teraz moÅ¼e pojawiÄ‡ siÄ™ pytanie â€“ no ale po co to? Obiekty w JavaScript moÅ¼na tworzyÄ‡ na wiele rÃ³Å¼nych sposobÃ³w â€“ co daje nam fabryka?

PamiÄ™tajmy, Å¼e Simple Factory, jest jedynie wzorcem, a nie nowym sposobem na tworzenie obiektÃ³w. Obiekty bÄ™dziemy tworzyli w znany nam juÅ¼ sposÃ³b (np. poprzez klasy, sprawdÅº inne moje wpisy), natomiast fabryka jedynie decyduje jaki obiekt i w jaki sposÃ³b stworzyÄ‡.

DziÄ™ki temu bÄ™dziemy tworzyÄ‡ obiekty zawsze za pomocÄ… tego samego interfejsu a ewentualne zmiany, poprawki, dodatkowe funkcjonalnoÅ›ci bÄ™dziemy juÅ¼ wykonywaÄ‡ w samej fabryce. DziÄ™ki temu nasz kod bÄ™dzie Å‚atwiejszy w utrzymaniu i Å‚atwo skalowalny.

## PrzykÅ‚ady

Teoria teoriÄ… â€“ zobaczmy teraz na przykÅ‚adach jak ten wzorzec moÅ¼emy zastosowaÄ‡ i jakie problemy nam rozwiÄ…Å¼e.

### PrzykÅ‚ad 1 â€“ Firma transportowa

ZaÅ‚Ã³Å¼my, Å¼e tworzymy aplikacjÄ™ dla firmy transportowej. PoczÄ…tkowo firma ta realizuje tylko przesyÅ‚ki rowerowe w jednym mieÅ›cie. Nowe zamÃ³wienie (tj. obiekt zawierajÄ…cy informacje na temat ceny, daty dostawy, przypisanego kuriera) tworzymy na podstawie docelowego adresu oraz rodzaju przesyÅ‚ki. Tworzenie takiego obiektu za pomocÄ… np. klasy bÄ™dzie doÅ›Ä‡ Å‚atwe. Co natomiast w przypadku, gdy firma siÄ™ rozwinie i zacznie realizowaÄ‡ dostawy rÃ³wnieÅ¼ za pomocÄ… samochodÃ³w osobowych, busÃ³w, pociÄ…gÃ³w? I do tego rozwinie dziaÅ‚alnoÅ›Ä‡ na skalÄ™ krajowÄ…? MoÅ¼emy tworzyÄ‡ zamÃ³wienia za pomocÄ… kolejnych klas, ale wtedy rÃ³Å¼ne zamÃ³wienia bÄ™dÄ… posiadaÅ‚y rÃ³Å¼ne interfejsy. Do tego czeka nas stosowanie if-ologii w kaÅ¼dym miejscu aplikacji, gdzie napotkamy na tworzenie zamÃ³wienia.

Wzorzec fabryki pozwoli nam na duÅ¼o Å‚atwiejsze zarzÄ…dzanie takim stanem. Jako pragmatyczni programiÅ›ci, przewidzieliÅ›my, Å¼e zamÃ³wienie moÅ¼e byÄ‡ w przyszÅ‚oÅ›ci realizowane w inny sposÃ³b niÅ¼ tylko na rowerze. I napisaliÅ›my coÅ› takiego jak w przykÅ‚adzie poniÅ¼ej:

```js
/* Pojedyncze zamÃ³wienie tworzone bezpoÅ›rednio z klasy - maÅ‚o skalowalne rozwiÄ…zanie */
class Zamowienie {
  constructor(nadanie, odbior, przesylka) {
    this.nadanie = nadanie;
    this.odbior = odbior;
    this.przesylka = przesylka;
  }
  // PozostaÅ‚a logika - np. przypisanie kuriera, obliczenie ceny, itp.
}

const zamowienie = new Zamowienie(
  "ul. MarszaÅ‚kowska 10, Warszawa",
  "ul. SabaÅ‚y 10/12, Warszawa",
  "List A4"
);

/* -- Tworzymy fabrykÄ™ w celu obsÅ‚ugi rÃ³Å¼nego rodzaju zamÃ³wieÅ„ -- */

function fabrykaZamowien(nadanie, odbior, przesylka) {
  /* Implementujemy logikÄ™ do wyboru wÅ‚aÅ›ciwego Å›rodka transportu. 
     Tutaj dla uÅ‚atwienia decydujemy tylko na podstawie odlegÅ‚oÅ›ci */

  const odleglosc = liczOdleglosc();

  if (odleglosc > 10 && odleglosc < 50) {
    return new ZamowienieSamochod(nadanie, odbior, przesylka);
  }
  if (odleglosc > 50) {
    return new ZamowienieBus(nadanie, odbior, przesylka);
  }
  return new ZamowienieRower(nadanie, odbior, przesylka);
}

/* Klasy, ktÃ³re bÄ™dÄ… wÅ‚aÅ›ciwymi twÃ³rcami obiektÃ³w */

class ZamowienieSamochod {
  constructor(nadanie, odbior, przesylka) {
    this.nadanie = nadanie;
    this.odbior = odbior;
    this.przesylka = przesylka;
  }
  // PozostaÅ‚a logika - wszystko co zwiÄ…zane z obsÅ‚uÅ¼eniem przesyÅ‚ki samochodem
}

class ZamowienieBus {
  constructor(nadanie, odbior, przesylka) {
    this.nadanie = nadanie;
    this.odbior = odbior;
    this.przesylka = przesylka;
  }
  // PozostaÅ‚a logika - wszystko co zwiÄ…zane z obsÅ‚uÅ¼eniem przesyÅ‚ki busem
}

class ZamowienieRower {
  constructor(nadanie, odbior, przesylka) {
    this.nadanie = nadanie;
    this.odbior = odbior;
    this.przesylka = przesylka;
  }
  // PozostaÅ‚a logika - wszystko co zwiÄ…zane z obsÅ‚uÅ¼eniem przesyÅ‚ki rowerem
}

/* PrzesyÅ‚kÄ™ tworzymy zawsze w ten sam sposÃ³b (za pomocÄ… tego samego interfejsu).
   To fabryka jest odpowiedzialna za odpowienie przygotowanie zamÃ³wienia.
   Dodanie nowej metody dostawy nie popsuje i nie spowoduje koniecznoÅ›ci edycji poniÅ¼szego kodu. */

const zamowienie1 = new fabrykaZamowien(
  "ul. MarszaÅ‚kowska 10, Warszawa",
  "ul. SabaÅ‚y 10/12, Warszawa",
  "List A4"
);

const zamowienie2 = new fabrykaZamowien(
  "ul. MarszaÅ‚kowska 10, Warszawa",
  "ul. Szkolna, GdaÅ„sk",
  "Paczka 50x50"
);

const zamowienie3 = new fabrykaZamowien(
  "ul. DÅ‚uga 1, PÅ‚ock",
  "ul. SÅ‚owackiego 15, GÄ…bin",
  "Paczka 20x20"
);
```

### PrzykÅ‚ad 2 â€“ Fabryka (tym razem prawdziwa ğŸ™‚) samochodÃ³w

W drugim przykÅ‚adzie bÄ™dziemy mieli do czynienia z liniÄ… produkcyjnÄ… samochodÃ³w. PrzykÅ‚ad ten jest tutaj umieszczony gÅ‚Ã³wnie po to, aby pokazaÄ‡, Å¼e fabrykÄ… (wzorzec) rÃ³wnieÅ¼ moÅ¼e byÄ‡ klasa, a nie funkcja jak to miaÅ‚o miejsce w przypadku firmy transportowej.

Wzorzec jedynie podpowiada nam, w jaki sposÃ³b moÅ¼emy rozwiÄ…zaÄ‡ dany problem. Nie narzuca jednego sztywnego sposobu implementacji. Wzorzec â€Fabrykiâ€ sugeruje nam, aby do tworzenia obiektÃ³w uÅ¼ywaÄ‡ jednego, spÃ³jnego interfejsu. DziÄ™ki temu obiekty tworzone sÄ… w przewidywalny sposÃ³b i caÅ‚y proces jest scentralizowany. Jak to zrobimy â€“ to juÅ¼ nasza decyzja.

WracajÄ…c do przykÅ‚adu â€“ wyobraÅºmy sobie teraz fabrykÄ™ samochodÃ³w oraz fragment aplikacji do zarzÄ…dzania produkcjÄ… (chociaÅ¼ wÄ…tpiÄ™, Å¼eby coÅ› takiego byÅ‚o oparte o JavaScript ğŸ˜‰). Fabryka ta produkuje zarÃ³wno samochody osobowe, jak i busy. W przypadku samochodÃ³w osobowych moÅ¼emy dodatkowo okreÅ›liÄ‡ liczbÄ™ drzwi a w przypadku busÃ³w iloÅ›Ä‡ foteli dla pasaÅ¼erÃ³w.

```js
/* Tworzymy FabrykÄ™ dla pojazdÃ³w */

class FabrykaPojazdow {
  constructor(opcje) {
    let pojazd;
    switch (opcje.rodzaj) {
      case "osobowy":
        pojazd = new Osobowy(opcje.kolor, opcje.skrzynia, opcje.drzwi);
        break;
      case "bus":
        pojazd = new Bus(opcje.kolor, opcje.skrzynia, opcje.fotele);
        break;
    }
    return pojazd;
  }
}

/* Klasy, ktÃ³re bÄ™dÄ… "produkowaÅ‚y" wÅ‚aÅ›ciwy pojazd */

class Osobowy {
  constructor(kolor, skrzynia, drzwi) {
    this.kolor = kolor;
    this.skrzynia = skrzynia;
    this.drzwi = drzwi;
  }

  produkuj() {
    return `Wyprodukuj samochÃ³d osobowy`;
  }
}

class Bus {
  constructor(kolor, skrzynia, fotele) {
    this.kolor = kolor;
    this.skrzynia = skrzynia;
    this.fotele = fotele;
  }

  produkuj() {
    return `Wyprodukuj busa`;
  }
}

/* UÅ¼ycie Fabryki - ponownie mamy jeden spÃ³jny interfejs dla kaÅ¼dego pojazdu */

let zamowienie1 = {
  rodzaj: "osobowy",
  kolor: "biaÅ‚y",
  skrzynia: "automatyczna",
  drzwi: 4,
};

let zamowienie2 = {
  rodzaj: "bus",
  kolor: "srebrny",
  skrzynia: "manualna",
  fotele: 6,
};

let pojazd1 = new FabrykaPojazdow(zamowienie1);
let pojazd2 = new FabrykaPojazdow(zamowienie2);
```

## Podsumowanie

Mam nadziejÄ™, Å¼e krÃ³tki wstÄ™p oraz dwa powyÅ¼sze przykÅ‚ady sÄ… wystarczajÄ…ce, Å¼eby zrozumieÄ‡ idee wzorca Simple Factory.

Z "FabrykÄ…" spotkamy siÄ™ jeszcze w dwÃ³ch kolejnych wzorcach, tj. Factory Method oraz Abstract Factory. RÃ³Å¼niÄ… siÄ™ one implementacjÄ…, jednak kaÅ¼dy z nich ma za zadanie dostarczyÄ‡ optymalny sposÃ³b na tworzenie nowych obiektÃ³w.
