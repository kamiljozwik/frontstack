<section>
## Nowy skÅ‚adnik `npm query` do selekcji zaleÅ¼noÅ›ci

Zaprezentowano nowe podejÅ›cie do zarzÄ…dzania zaleÅ¼noÅ›ciami w projekcie Node.js, dziÄ™ki komendzie `npm query` oraz selektorom zaleÅ¼noÅ›ci, opartych na znanej skÅ‚adni CSS. To narzÄ™dzie pozwala nam na szybkie i elastyczne filtrowanie zaleÅ¼noÅ›ci w projekcie.

Oto kilka przykÅ‚adÃ³w:

1. Wypisanie wszystkich zaleÅ¼noÅ›ci (podobnie jak `npm list --all`):

   ```bash
   npm query "*"
   ```

2. Znalezienie wszystkich wersji `react` i `lodash` w projekcie:

   ```bash
   npm query "#react, #lodash"
   ```

3. Wyszukiwanie wersji `react`, ktÃ³re nie sÄ… zaleÅ¼noÅ›ciami typu peer:

   ```bash
   npm query "#react:not(.peer)"
   ```

4. Znalezienie zaleÅ¼noÅ›ci z licencjÄ… `MIT`:

   ```bash
   npm query "[license=MIT]"
   ```

5. Wyszukiwanie zaleÅ¼noÅ›ci z repozytorium git:

   ```bash
   npm query ":type(git)"
   ```

6. Sprawdzenie, ktÃ³re zaleÅ¼noÅ›ci transakcyjne uÅ¼ywajÄ… skryptu `postinstall`:

   ```bash
   npm query ":attr(scripts, [postinstall]):not(:root > *)"
   ```

ğŸ‘‰ WiÄ™cej informacji do znalezienia [tutaj](https://github.blog/changelog/2022-08-03-introducing-the-new-npm-dependency-selector-syntax/), [tutaj](https://docs.npmjs.com/cli/v10/using-npm/dependency-selectors) oraz [tutaj](https://www.youtube.com/watch?v=h_ZpixOgKDY).

</section>

<section>
## Odnoszenie siÄ™ do wartoÅ›ci z `package.json` w skryptach `npm`

Czy wiesz, Å¼e moÅ¼esz odnosiÄ‡ siÄ™ do wartoÅ›ci zdefiniowanych w pliku `package.json` bezpoÅ›rednio w definicjach skryptÃ³w npm/yarn? To Å›wietne rozwiÄ…zanie, ktÃ³re pomaga uniknÄ…Ä‡ powtÃ³rzeÅ„, szczegÃ³lnie w wiÄ™kszych projektach.

Przyjrzyjmy siÄ™ przykÅ‚adowi:

```json
{
  "name": "my-package",
  "config": {
    "src": "./src/*"
  },
  "scripts": {
    "lint": "eslint $npm_package_config_src",
    "test": "jest $npm_package_config_src"
  }
}
```

W powyÅ¼szym przykÅ‚adzie zdefiniowaliÅ›my Å›cieÅ¼kÄ™ `./src/*` jako czÄ™Å›Ä‡ konfiguracji i odnosimy siÄ™ do niej w skryptach `lint` i `test`. DziÄ™ki temu, jeÅ›li Å›cieÅ¼ka ulegnie zmianie, wystarczy zaktualizowaÄ‡ jÄ… tylko w jednym miejscu.

Dodatkowo, wartoÅ›ci z `package.json` sÄ… dostÄ™pne rÃ³wnieÅ¼ w Node.js poprzez `process.env`, gdy uruchamiasz skrypty za pomocÄ… `yarn`:

```json
// package.json
{
  "foo": "bar",
  "scripts": {
    "start": "node index.js"
  }
}
```

```js
// index.js
console.log(process.env.npm_package_foo); // 'bar'
```

Kiedy uruchomisz `yarn start`, plik `index.js` bÄ™dzie miaÅ‚ dostÄ™p do wartoÅ›ci z `package.json` poprzez `process.env`.

To super pomocne rozwiÄ…zanie, ktÃ³re moÅ¼e znacznie upraszczaÄ‡ zarzÄ…dzanie skryptami i konfiguracjÄ… w projektach! ğŸ‰

</section>

<section>
## Mierzenie wydajnoÅ›ci w JavaScript z `performance.now()`

Czy wiesz, Å¼e w JavaScript moÅ¼emy precyzyjnie mierzyÄ‡ czas wykonania naszego kodu za pomocÄ… funkcji `performance.now()`? Jest ona znacznie dokÅ‚adniejsza niÅ¼ `Date.now()` i pozwala na uzyskanie wyniku z dokÅ‚adnoÅ›ciÄ… do mikrosekund.

SpÃ³jrzmy na przykÅ‚ad:

```js
const start = performance.now();

// Tutaj umieÅ›Ä‡ swÃ³j kod, ktÃ³rego wydajnoÅ›Ä‡ chcesz zmierzyÄ‡
for (let i = 0; i < 1000; i++) {
  console.log(i);
}

const end = performance.now();
console.log(`Czas wykonania: ${end - start} milisekund`);
```

W powyÅ¼szym przykÅ‚adzie mierzymy czas wykonania pÄ™tli `for`. Funkcja `performance.now()` zwraca czas w milisekundach od momentu uruchomienia strony / aplikacji, wiÄ™c poprzez odjÄ™cie czasu startu od czasu koÅ„ca, otrzymujemy czas wykonania naszego kodu.

Jest to szczegÃ³lnie uÅ¼yteczne podczas optymalizacji wydajnoÅ›ci aplikacji, gdy chcemy zrozumieÄ‡, ktÃ³re fragmenty kodu sÄ… "wÄ…skimi gardÅ‚ami" naszej aplikacji. Albo gdy chcemy udowodniÄ‡, Å¼e nasz kod jest szybszy od kodu kolegi ğŸ˜.

</section>

<section>
## Kondycjne klasy w Tailwind CSS

Kondycyjne dodawanie klas w Tailwindzie nie jest tak oczywiste, jak mogÅ‚oby siÄ™ wydawaÄ‡. Tailwind generuje pliki CSS na podstawie klas ktÃ³re znajdzie w kodzie, wiÄ™c dodawanie logiki warunkowej do klas moÅ¼e spowodowaÄ‡, Å¼e dana klasa nie zostanie uwzglÄ™dniona przez Tailwinda w trakcie budowania strony. Na szczÄ™Å›cie moÅ¼emy to Å‚atwo rozwiÄ…zaÄ‡ za pomocÄ… maÅ‚ego helpera:

```ts
import clsx, { type ClassValue } from "clsx";
import { twMerge } from "tailwind-merge";

/** Utility function to add Tailwind classes conditionally */
export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs));
}
```

PrzykÅ‚ad uÅ¼ycia w komponencie Reacta:

```tsx
import { cn } from "./utils/cn";

export function Button({ variant = "primary" }) {
  return (
    <button
      className={cn("px-4 py-2 rounded-md", {
        "bg-blue-500 text-white": variant === "primary", // klasy dodane tylko wtedy, gdy "variant" jest rÃ³wny "primary"
        "bg-gray-200 text-gray-800": variant === "secondary", // klasy dodane tylko wtedy, gdy "variant" jest rÃ³wny "secondary"
      })}
    >
      Click me
    </button>
  );
}
```

ğŸ‘‰ WiÄ™cej informacji o tym helperze moÅ¼ecie znaleÅºÄ‡ [tutaj](https://www.youtube.com/shorts/1Hgc6EU9PSg) oraz [tutaj](https://www.youtube.com/watch?v=re2JFITR7TI).

</section>

<section>
## document.designMode

Tryb projektowania jest tÄ… funkcjonalnoÅ›ciÄ… w przeglÄ…darce, ktÃ³ra pozwala nam bezpoÅ›rednio edytowaÄ‡ dokument (czyli zawartoÅ›Ä‡ tekstowÄ… strony internetowej). DomyÅ›lnie ta wÅ‚aÅ›ciwoÅ›Ä‡ jest oczywiÅ›cie wyÅ‚Ä…czona, ale aby uruchomiÄ‡ ten feature, wystarczy otworzyÄ‡ DevToolsy a nastÄ™pnie wpisaÄ‡ w konsoli:

```
document.designMode="on"
```

OczywiÅ›cie moÅ¼emy osiÄ…gnÄ…Ä‡ to samo edytujÄ…c HTML bezpoÅ›rednio w DevToolsach, ale trzeba przyznaÄ‡, Å¼e jest to o wiele wygodniejsze rozwiÄ…zanie ğŸ˜‰.

PrzykÅ‚adowe uÅ¼ycie ğŸ‘‰ [https://twitter.com/sulco/status/1177559150563344384](https://twitter.com/sulco/status/1177559150563344384)

</section>

<section>
## Usuwanie nieuÅ¼ywanych `node_modules`

Wszyscy znamy problem gromadzenia siÄ™ wielu repozytoriÃ³w na naszym dysku. Przy projektach korzystajÄ…cych z Node.js, foldery `node_modules` mogÄ… zajmowaÄ‡ setki megabajtÃ³w ğŸ¤¯. RÄ™czne ich usuwanie to doÅ›c Å¼mudna praca, ale na szczÄ™Å›cie istnieje prosty sposÃ³b - paczka [npkill](https://www.npmjs.com/package/npkill).

MoÅ¼emy jÄ… uruchomiÄ‡ bezpoÅ›rednio w terminalu:

```
$ npx npkill
```

Po uruchomieniu tego polecenia, `npkill` wyÅ›wietli listÄ™ wszystkich folderÃ³w `node_modules` w danym, oraz w zagnieÅ¼dÅ¼onych katalogach i pozwoli na ich bÅ‚yskawiczne usuniÄ™cie z dysku ğŸ§¹.

</section>

<section>
## Typowanie `process.env` w TypeScript

Szybki, czysty i prosty sposÃ³b na typowanie `process.env` w TypeScript z uÅ¼yciem biblioteki [zod](https://zod.dev/).

```ts
import { z } from "zod";

const envVariables = z.object({
  DATABASE_URL: z.string(),
  CUSTOM_STUFF: z.string(),
});

envVariables.parse(process.env);

declare global {
  namespace NodeJS {
    interface ProcessEnv extends z.infer<typeof envVariables> {}
  }
}

process.env.DATABASE_URL;
//          ^ Auto-completion ğŸ¥³
```

Zobacz wiÄ™cej [tutaj](https://www.youtube.com/watch?v=q1im-hMlKhM).

</section>

<section>
## Loose Autocomplete w TypeScript

Chcesz, aby zdefiniowany przez Ciebie typ [union](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#union-types) przyjmowaÅ‚ rÃ³wnieÅ¼ ogÃ³lnego `string`-a, ale zachowaÅ‚ moÅ¼liwoÅ›Ä‡ automatycznego uzupeÅ‚niania zdefiniowanych wartoÅ›ci? MoÅ¼esz uÅ¼yÄ‡ pewnego tricku, aby to osiÄ…gnÄ…Ä‡ ğŸª„

Oto przykÅ‚ad:

```typescript
// VS Code nie bÄ™dzie podpowiadaÅ‚ wartoÅ›ci "foo", "bar" i "baz" ğŸ˜¢
type MyType = "foo" | "bar" | "baz" | string;

// MoÅ¼emy podaÄ‡ dowolny string, ale VS Code bÄ™dzie podpowiadaÅ‚ wartoÅ›ci "foo", "bar" i "baz" ğŸ¤©
type MyBetterType = "foo" | "bar" | "baz" | (string & {});
```

Teraz nasz typ jest bardziej elastyczny, ale nadal moÅ¼emy korzystaÄ‡ z automatycznego uzupeÅ‚niania w VS Code ğŸ’ª

</section>

<section>
## `useCallback` i `debounce` w React

Szybki snippet na to, aby poÅ‚Ä…czyÄ‡ ze sobÄ… `useCallback` oraz funkcjÄ™ `debounce()` (chyba nie muszÄ™ nikomu jej przedstawiaÄ‡ ğŸ˜‰) z biblioteki `lodash` (albo z naszej wÅ‚asnej implementacji).

```typescript
import { useMemo } from "react";
import debounce from "lodash.debounce";

function MyComponent() {
  const changeHandler = () => {
    // handle the event...
  };
  const eventHandler = () => {
    // handle the event...
  };

  // Option A: useCallback() stores the debounced callback
  const debouncedChangeHandler = useCallback(debounce(changeHandler, 300), []);

  // Option B: useMemo() stores the debounced callback
  const debouncedEventHandler = useMemo(() => debounce(eventHandler, 300), []);

  // ...
}
```

SprawdÅº dokÅ‚adniejszy opis i wiÄ™cej przykÅ‚adÃ³w [w tym artykule](https://dmitripavlutin.com/react-throttle-debounce/).

</section>

<section>
## `extends keyof` vs. `in keyof` w TypeScript

Czy zdarzyÅ‚o Ci siÄ™ czasami trochÄ™ pogubiÄ‡ lub nie do koÅ„ca rozumieÄ‡ rÃ³Å¼nicÄ™ pomiÄ™dzy `extends keyof` i `in keyof` w TypeScript?

Oto krÃ³tkie wyjaÅ›nienie:

`extends keyof` jest uÅ¼ywane w TypeScript dla typÃ³w generycznych. Wskazuje, Å¼e typ generyczny musi byÄ‡ kluczem okreÅ›lonego obiektu.

Oto prosty przykÅ‚ad:

```typescript
function getProperty<T, K extends keyof T>(obj: T, key: K): T[K] {
  return obj[key];
}

let x = { a: 1, b: 2, c: 3, d: 4 };

console.log(getProperty(x, "a")); // Output: 1
console.log(getProperty(x, "m")); // Error: Argument of type '"m"' is not assignable to parameter of type '"a" | "b" | "c" | "d"'.
```

W tym przykÅ‚adzie `K extends keyof T` oznacza, Å¼e `K` powinien byÄ‡ kluczem obiektu `T`. Dlatego TypeScript wyÅ›wietli bÅ‚Ä…d, jeÅ›li sprÃ³bujesz uÅ¼yÄ‡ wÅ‚aÅ›ciwoÅ›ci, ktÃ³ra nie istnieje w obiekcie.

WyraÅ¼enie `in keyof` jest uÅ¼ywane z typami mapowanymi, ktÃ³re sÄ… sposobem na tworzenie nowych typÃ³w na podstawie starych. Tak wiÄ™c `in keyof` pozwala nam iterowaÄ‡ po kluczach typu obiektu.

Brzmi moÅ¼e nieco trudniej, ale spÃ³jrzmy na kolejny przykÅ‚ad:

```typescript
interface User {
  firstName: string;
  lastName: string;
  email: string;
  age: number;
  joinedDate: Date;
}

type AllStrings<T> = {
  [K in keyof T]: string; // nasz nowy typ bÄ™dzie zawieraÅ‚ wszystkie klucze z T
};

let user: User = {
  firstName: "John",
  lastName: "Doe",
  email: "john.doe@example.com",
  age: 30,
  joinedDate: new Date(2023, 1, 1),
};

let userInStrings: AllStrings<User> = {
  firstName: user.firstName,
  lastName: user.lastName,
  email: user.email,
  age: String(user.age),
  joinedDate: user.joinedDate.toISOString(),
};

console.log(userInStrings);
// Output: { firstName: 'John', lastName: 'Doe', email: 'john.doe@example.com', age: '30', joinedDate: '2023-02-01T00:00:00.000Z' }
```

Tutaj `AllStrings<T>` jest typem mapowanym, ktÃ³ry konwertuje wszystkie wÅ‚aÅ›ciwoÅ›ci `T` na ciÄ…gi znakÃ³w. UÅ¼ywamy `in keyof` (`[K in keyof T]`), aby przejÅ›Ä‡ przez kaÅ¼dy klucz w `T` i przypisaÄ‡ mu nowy typ (w tym przypadku `string`). W `userInStrings` uÅ¼ywamy tego zmapowanego typu do utworzenia obiektu, w ktÃ³rym wszystkie wartoÅ›ci sÄ… Å‚aÅ„cuchami, co moÅ¼e byÄ‡ przydatne do niektÃ³rych rodzajÃ³w przetwarzania, serializacji, rejestrowania lub debugowania.

</section>

<section>
## TypeScript `Discriminated Unions`

Bardzo czÄ™sto w naszych projektach moÅ¼emy spotykaÄ‡ siÄ™ z typem takim jak ten poniÅ¼ej:

```typescript
type Order = {
  status: string; // "string" jest doÅ›Ä‡ szerokim typem, a pewnie statusy zamÃ³wieÅ„ sÄ… ograniczone do kilku wartoÅ›ci
  name: string;
  description?: string;
  expectedDelivery?: Date; // czemu opcjonalny?
  deliveredOn?: Date; // kiedy opcjonalny, a kiedy nie?
};
```

Ten sposÃ³b definiowania typÃ³w jest doÅ›Ä‡ nieczytelny (czemu niektÃ³re wÅ‚aÅ›ciwoÅ›ci sÄ… opcjonalne?) i nieelastyczny. W takich przypadkach warto zastanowiÄ‡ siÄ™ nad uÅ¼yciem tzw. [Discriminated Unions](https://www.typescriptlang.org/docs/handbook/2/narrowing.html#discriminated-unions).

```typescript
type Order = {
  name: string;
  description?: string;
} & (
  | {
      status: "ready"; // "expectedDelivery" i "deliveredOn" nie powinny tutaj siÄ™ poajawiÄ‡
    }
  | {
      status: "inProgress";
      expectedDelivery: Date; // DostÄ™pne wtedy, gdy status jest "inProgress"
    }
  | {
      status: "complete";
      expectedDelivery: Date; // DostÄ™pne wtedy, gdy status jest "complete"
      deliveredOn: Date; // DostÄ™pne wtedy, gdy status jest "complete"
    }
);
```

Ten zapis moÅ¼e wydawaÄ‡ siÄ™ bardziej rozwlekÅ‚y, ale dziaÅ‚a juÅ¼ jako prosta dokumentacja domeny, usuwa mnÃ³stwo niejasnoÅ›ci i pozwala pisaÄ‡ bardziej przejrzysty kod. Teraz TS bÄ™dzie w stanie "domyÅ›leÄ‡" siÄ™, ktÃ³re wÅ‚aÅ›ciwoÅ›ci sÄ… wymagane w zaleÅ¼noÅ›ci od statusu zamÃ³wienia.

Rozszerzenie tego tematu moÅ¼na znaleÅºÄ‡ w ciekawych artykule: [How I ease the next developer reading my code](https://dev.to/noriste/how-i-ease-the-next-developer-reading-my-code-1986)

</section>

<section>

## `infer` - zaawansowany typ warunkowy w TS

W TypeScript moÅ¼emy wykorzystaÄ‡ typy warunkowe wraz z sÅ‚owem kluczowym `infer` do wnioskowania o typach. Przyjrzyjmy siÄ™ poniÅ¼szemu przykÅ‚adowi:

```typescript
type ArrayTypes<T> = T extends (infer U)[] ? U : never;

let arr = [1, "2", []];
type test = ArrayTypes<typeof arr>; // typ test = string | number | any[]
```

W tym przykÅ‚adzie, typ `ArrayTypes<T>` bierze typ `T` i sprawdza, czy `T` jest typem tablicy. JeÅ›li tak, to inferuje typ `U` z tablicy `T[]` i zwraca `U`. W przeciwnym razie zwraca `never`.

WaÅ¼ne jest, aby zauwaÅ¼yÄ‡, Å¼e `infer` musi byÄ‡ podÅ‚Ä…czony do `U`, a nie do `[]`. Dlatego korzystamy z nawiasÃ³w w `(infer U)[]`. Bez nawiasÃ³w, TypeScript zinterpretowaÅ‚by to jako `infer (U[])`, co byÅ‚oby niepoprawne, poniewaÅ¼ `infer` moÅ¼e byÄ‡ uÅ¼ywane tylko do inferencji typÃ³w, a nie struktur typÃ³w takich jak tabliceã€33â€ sourceã€‘.

Kolejny przykÅ‚ad, tym razem z obiektem. W tym przypadku `infer` stworzy nam typ, ktÃ³ry bÄ™dzie zawieraÅ‚ wszystkie typy wartoÅ›ci obiektu:

```typescript
type ObjectTypes<T> = T extends { a: infer U; b: infer U } ? U : never;

let obj = { a: 1, b: "2" };
type Test = ObjectTypes<typeof obj>; // typ Test = string | number
```

Jak widaÄ‡ moÅ¼liwoÅ›ci tutaj sÄ… ogromne, wiÄ™c warto zapoznaÄ‡ siÄ™ z tym tematem.

</section>

<section>
## Typy warunkowe w TypeScript

Typy warunkowe w TypeScript pozwalajÄ… na wybÃ³r typu w zaleÅ¼noÅ›ci od warunku. Jest to doÅ›Ä‡ przydatne narzÄ™dzie, ktÃ³re pozwala na tworzenie bardziej zÅ‚oÅ¼onych typÃ³w.

```typescript
type IsString<T> = T extends string ? true : false;

type X = IsString<"hello">; // true
type Y = IsString<number>; // false
type Z = IsString<{ name: string }>; // false
```

W tym prostym przykÅ‚adzie, `IsString` jest typem warunkowym, ktÃ³ry sprawdza, czy podany typ `T` jest stringiem. JeÅ›li tak, to zwraca `true`, a w przeciwnym razie zwraca `false`.

PamiÄ™taj, Å¼e typy warunkowe mogÄ… byÄ‡ zagnieÅ¼dÅ¼one i mogÄ… uÅ¼ywaÄ‡ dowolnej logiki (moÅ¼emy np. uÅ¼ywaÄ‡ tego sprawdzenia w `if`-ach i zawÄ™Å¼aÄ‡ bardziej typowanie), ktÃ³ra jest dostÄ™pna w typach, co czyni je niezwykle elastycznymi i potÄ™Å¼nymi narzÄ™dziami do modelowania typÃ³w w TypeScript.

</section>

<section>
## `unknown` vs `any` w TS

W TypeScript typ `unknown` jest bezpieczniejszym odpowiednikiem typu `any`. Podczas gdy `any` pozwala nam na wszystko, `unknown` wymusza sprawdzanie typu przed wykonaniem operacji.

```ts
let foo: any = "hello";
foo = foo.split("").reverse().join(""); // ZadziaÅ‚a, ale...

let foo2: any = { greet: "hello" };
foo2 = foo.split("").reverse().join(""); // TS nie wykryje bÅ‚Ä™du, ale dostaniemy bÅ‚Ä…d w konsoli

let bar: unknown = "world";
bar = bar.split("").reverse().join(""); // TS podkreÅ›li nam bÅ‚Ä…d w edytorze, poniewaÅ¼ nie moÅ¼emy uÅ¼yÄ‡ metody "split" na nieznanym typie.

bar = (bar as string).split("").reverse().join(""); // OK, poniewaÅ¼ zadeklarowaliÅ›my typ, ale moÅ¼e byÄ‡ lepiej...
bar = typeof bar === "string" ? bar.split("").reverse().join("") : bar; // Jeszcze lepiej, poniewaÅ¼ sprawdziliÅ›my typ
```

Z `unknown` TypeScript zapewnia, Å¼e musiz sprawdziÄ‡ typ przed wykonaniem operacji, wiÄ™c jest to duÅ¼o bezpieczniejsze podejÅ›cie niÅ¼ `any`.

</section>

<section>
## Aliasy podczas importÃ³w w TS

Macie juÅ¼ doÅ›Ä‡ _kropkowania_ podczas importÃ³w? [Aliasy](https://www.typescriptlang.org/tsconfig#paths) w TS mogÄ… nam tutaj znacznie uproÅ›ciÄ‡ Å¼ycie. Do pliku `tsconfig.json` wystarczy dodaÄ‡ nastÄ™pujÄ…cÄ… konfiguracjÄ™:

```json title="tsconfig.json"
{
  "compilerOptions": {
    // Your other options...
    "paths": {
      "@/*": ["./src/*"]
    }
  }
}
```

Od teraz moÅ¼emy zaczynaÄ‡ nasze importy od zdefiniowanego wczeÅ›niej poziomu w naszej aplikacji:

```ts
import { Button } from "@/components/Button"; // ğŸ¤© import z "src/components/Button"
import { OtherButton } from "../../../components/Button"; // ğŸ˜¥
```

Taka skÅ‚adnia jest duÅ¼o czytelniejsza i Å‚atwiejsza do utrzymania. JeÅ›li zmienimy zagnieÅ¼dÅ¼enie bÄ…dÅº poÅ‚oÅ¼enie folderu, to nie musimy martwiÄ‡ siÄ™ o zmianÄ™ Å›cieÅ¼ek w naszym kodzie ğŸ’ª.

</section>

<section>
## WartoÅ›Ä‡ domyÅ›lna dla kaÅ¼dego klucza w obiekcie

Czasami chcemy (niezbyt czÄ™sto, ale moÅ¼e siÄ™ zdarzyÄ‡ ğŸ˜‰), aby wÅ‚aÅ›ciwoÅ›ci obiektu byÅ‚y automatycznie inicjalizowane. Powszechnym sposobem radzenia sobie z tym jest korzystanie z metod `getter` i `setter`. Jednak moÅ¼e to staÄ‡ siÄ™ uciÄ…Å¼liwe, jeÅ›li mamy wiele wÅ‚aÅ›ciwoÅ›ci. WÅ‚aÅ›nie tutaj obiekt [Proxy](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy?retiredLocale=pl) moÅ¼e okazaÄ‡ siÄ™ bardzo pomocny.

`Proxy` w JavaScript jest uÅ¼ywane do definiowania niestandardowego zachowania dla podstawowych operacji (np. wyszukiwanie, przypisanie, wyliczanie, wywoÅ‚ywanie funkcji itp.) obiektÃ³w.

Proxy moÅ¼emy rÃ³wnieÅ¼ uÅ¼yÄ‡ wiÄ™c rÃ³wnieÅ¼ do automatycznego inicjowania wÅ‚aÅ›ciwoÅ›ci obiektÃ³w, ktÃ³rych wÅ‚aÅ›ciwoÅ›ci nie sÄ… do koÅ„ca znane:

```js
const autoInit = (defaultValue) =>
  new Proxy(
    {},
    {
      get: (target, name) =>
        name in target ? target[name] : (target[name] = defaultValue),
    }
  );

const myObject = autoInit([]);

console.log(myObject.foo); // []

myObject.foo.push("bar");

console.log(myObject.foo); // ['bar']
```

W tym przykÅ‚adzie kaÅ¼da wÅ‚aÅ›ciwoÅ›Ä‡ `myObject`, ktÃ³ra jest dostÄ™pna przed jej ustawieniem, zostanie automatycznie zainicjowana na pustÄ… tablicÄ™ (lub dowolnÄ… innÄ… domyÅ›lnÄ… wartoÅ›Ä‡, ktÃ³rÄ… podamy). MoÅ¼e to byÄ‡ doÅ›Ä‡ przydatne w sytuacjach w ktÃ³rych chcemy uniknÄ…Ä‡ wartoÅ›ci `undefined`.

</section>

<section>
## Szybkie sprawdzanie wÅ‚aÅ›ciwoÅ›ci obiektu w JavaScript

Czy wiedziaÅ‚eÅ›, Å¼e moÅ¼esz sprawdziÄ‡, czy obiekt ma danÄ… wÅ‚aÅ›ciwoÅ›Ä‡ uÅ¼ywajÄ…c operatora `in`? Oto jak to zrobiÄ‡:

```javascript
const myObject = { foo: "bar" };

console.log("foo" in myObject); // true
console.log("baz" in myObject); // false
```

Szybko i czysto, bez potrzeby sprawdzania `undefined` ğŸ˜‰

</section>

<section>
## Readonly w TS

W jÄ™zyku TypeScript moÅ¼na uÅ¼yÄ‡ modyfikatora `readonly`, aby wskazaÄ‡, Å¼e wÅ‚aÅ›ciwoÅ›Ä‡ klasy lub interfejsu jest tylko do odczytu, co oznacza, Å¼e po przypisaniu do niej wartoÅ›ci nie moÅ¼na jej zmieniÄ‡. Oto krÃ³tki przykÅ‚ad:

```ts
interface Point {
  readonly x: number;
  readonly y: number;
}

let p: Point = { x: 10, y: 20 };
p.x = 5; // Error: Cannot assign to 'x' because it is a read-only property
```

W powyÅ¼szym kodzie `x` i `y` w `Point` sÄ… wÅ‚aÅ›ciwoÅ›ciami tylko do odczytu ğŸ’ª.

</section>

<section>
## Brak mockÃ³w w testach z `React Router (v6)` i `React Testing Library`

Customowy `render()`, za pomocÄ… ktÃ³rego moÅ¼emy Å‚atwo testowaÄ‡ komponenty wykorzystujÄ…ce nawigacjÄ™ w naszej aplikacji:

```js
import React, { isValidElement } from "react";
import { render } from "@testing-library/react";
import { RouterProvider, createMemoryRouter } from "react-router-dom";

export function renderWithRouter(children, routes = []) {
  const options = isValidElement(children)
    ? { element: children, path: "/" }
    : children;

  const router = createMemoryRouter([{ ...options }, ...routes], {
    initialEntries: [options.path],
    initialIndex: 1,
  });

  return render(<RouterProvider router={router} />);
}
```

DokÅ‚adniejsze omÃ³wienie powyÅ¼szego kodu oraz przykÅ‚adowe uÅ¼ycie do znalezienia w [tym artykule](https://webup.org/blog/how-to-avoid-mocking-in-react-router-v6-tests/).

</section>

<section>
## TS `type guards` dla tablic danych

MajÄ…c tablicÄ™ danych, ktÃ³ra moÅ¼e zawieraÄ‡ rÃ³Å¼ne typy (czyli np. nie jesteÅ›my pewni odpowiedzi z API), to moÅ¼emy uÅ¼yÄ‡ [type guard](https://www.typescriptlang.org/docs/handbook/2/narrowing.html#using-type-predicates) i metodÄ™ `.every()` zamiast `if-Ã³w`, Å¼eby zawÄ™ziÄ‡ sobie typowanie.

```ts
// type guard z uÅ¼yciem sÅ‚owa kluczowego "is"
function isArrayOfNumbers(arr: unknown[]): arr is number[] {
  return arr.every((element) => typeof element === "number");
}

const arr = [1, 2, 3, 4, 5];

if (isArrayOfNumbers(arr)) {
  console.log(arr[0].toFixed); // âœ… OK, wiemy, Å¼e "arr" jest tablicÄ… liczb
} else {
  console.log(arr[0].toFixed); // â›” ERROR, nie moÅ¼emy uÅ¼yÄ‡ metody ".toFixed()" na typie "unknown"
}
```

PowyÅ¼ej mamy prosty przykÅ‚ad z tablicÄ… liczb, ale moÅ¼emy teÅ¼ uÅ¼yÄ‡ tego rozwiÄ…zania do bardziej skomplikowanych typÃ³w danych.

</section>
