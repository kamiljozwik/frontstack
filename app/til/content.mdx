<section>
## Readonly w TS

<small>ğŸ“… 30.05.2023</small>

W jÄ™zyku TypeScript moÅ¼na uÅ¼yÄ‡ modyfikatora `readonly`, aby wskazaÄ‡, Å¼e wÅ‚aÅ›ciwoÅ›Ä‡ klasy lub interfejsu jest tylko do odczytu, co oznacza, Å¼e po przypisaniu do niej wartoÅ›ci nie moÅ¼na jej zmieniÄ‡. Oto krÃ³tki przykÅ‚ad:

```ts
interface Point {
  readonly x: number;
  readonly y: number;
}

let p: Point = { x: 10, y: 20 };
p.x = 5; // Error: Cannot assign to 'x' because it is a read-only property
```

W powyÅ¼szym kodzie `x` i `y` w `Point` sÄ… wÅ‚aÅ›ciwoÅ›ciami tylko do odczytu ğŸ’ª.

</section>

<section>
## Brak mockÃ³w w testach z `React Router (v6)` i `React Testing Library`

<small>ğŸ“… 29.05.2023</small>

Customowy `render()`, za pomocÄ… ktÃ³rego moÅ¼emy Å‚atwo testowaÄ‡ komponenty wykorzystujÄ…ce nawigacjÄ™ w naszej aplikacji:

```js
import React, { isValidElement } from "react";
import { render } from "@testing-library/react";
import { RouterProvider, createMemoryRouter } from "react-router-dom";

export function renderWithRouter(children, routes = []) {
  const options = isValidElement(children)
    ? { element: children, path: "/" }
    : children;

  const router = createMemoryRouter([{ ...options }, ...routes], {
    initialEntries: [options.path],
    initialIndex: 1,
  });

  return render(<RouterProvider router={router} />);
}
```

DokÅ‚adniejsze omÃ³wienie powyÅ¼szego kodu oraz przykÅ‚adowe uÅ¼ycie do znalezienia w [tym artykule](https://webup.org/blog/how-to-avoid-mocking-in-react-router-v6-tests/).

</section>

<section>
## TS `type guards` dla tablic danych

<small>ğŸ“… 28.05.2023</small>

CoÅ› czego moÅ¼e nie nauczyÅ‚em siÄ™ dzisiaj, ale ostatnio potrzebowaÅ‚em z tego skorzystaÄ‡ i musiaÅ‚em wrÃ³ciÄ‡ do dokumentacji, Å¼eby sobie nieco ten temat przypomnieÄ‡.

JeÅ›li mamy tablicÄ™ danych, ktÃ³ra moÅ¼e zawieraÄ‡ rÃ³Å¼ne typy (czyli np. nie jesteÅ›my pewni odpowiedzi z API), to moÅ¼emy uÅ¼yÄ‡ [type guard](https://www.typescriptlang.org/docs/handbook/2/narrowing.html#using-type-predicates) i metodÄ™ `.every()` zamiast `if-Ã³w`, Å¼eby zawÄ™ziÄ‡ sobie typowanie.

```ts
// type guard z uÅ¼yciem sÅ‚owa kluczowego "is"
function isArrayOfNumbers(arr: unknown[]): arr is number[] {
  return arr.every((element) => typeof element === "number");
}

const arr = [1, 2, 3, 4, 5];

if (isArrayOfNumbers(arr)) {
  console.log(arr[0].toFixed); // âœ… OK, wiemy, Å¼e "arr" jest tablicÄ… liczb
} else {
  console.log(arr[0].toFixed); // â›” ERROR, nie moÅ¼emy uÅ¼yÄ‡ metody ".toFixed()" na typie "unknown"
}
```

PowyÅ¼ej mamy prosty przykÅ‚ad z tablicÄ… liczb, ale moÅ¼emy teÅ¼ uÅ¼yÄ‡ tego rozwiÄ…zania do bardziej skomplikowanych typÃ³w danych.

</section>
