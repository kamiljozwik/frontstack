import dockerBuild from "./dockerBuild.png";
import dockerRun from "./dockerRun.png";
import why from "./why.gif";
import cached from "./cachedDocker.png";
import node from "./dockerNode.png";
import buildTag from "./buildTag.png";
import desktop from "./dockerDesktop.png";
import nodeApp from "./nodeApp.png";
import hello from "./hello.png";

import { Info } from "../../components/posts";

export const meta = {
  title: "Docker â€“ Dockerfile i tworzenie obrazÃ³w",
  seo_desc:
    "Docker dockerfile. Tym razem dowiemy siÄ™ czym dla dockera jest plik dockerfile i jak za jego pomocÄ… moÅ¼emy budowaÄ‡ obrazy.",
  short:
    "W tym artykule samodzielnie od zera stworzymy obraz Dockera dla aplikacji zbudowanej w Express.js. a takÅ¼e uruchomimy jÄ… w kontenerze, wyjaÅ›niajÄ…c sobie po drodze wszystkie kroki.",
  date: "2021-08-13",
  tags: ["FrontOps", "Docker"],
};

Docker i jego podstawy â€“ ciÄ…g dalszy ğŸ™‚. W poprzednim poÅ›cie dowiedzieliÅ›my siÄ™, czym jest obraz i w jaki sposÃ³b moÅ¼emy tworzyÄ‡ z niego kontenery. Dzisiaj pÃ³jdziemy krok dalej i nauczymy siÄ™, w jaki sposÃ³b moÅ¼emy stworzyÄ‡ taki obraz samodzielnie i nastÄ™pnie wykorzystywaÄ‡ go do uruchamiania kontenerÃ³w. Jako frontend-owcy jesteÅ›my zaznajomieni z JavaScript, dlatego teÅ¼ stworzymy obraz za pomocÄ… Dockerfile w oparciu o [Node.js](https://nodejs.org/en) i framework [Express.js](https://expressjs.com/).

## Co tak w ogÃ³le chcemy osiÄ…gnÄ…Ä‡?

Jak juÅ¼ wiemy z poprzednich wpisÃ³w, obrazami Dockera mogÄ… byÄ‡ caÅ‚e aplikacje, ktÃ³re nastÄ™pnie moÅ¼emy uruchamiaÄ‡ wszÄ™dzie tam, gdzie zainstalowany jest Docker. Obrazy zawierajÄ… rÃ³wnieÅ¼ wszystkie wymagane pliki, ktÃ³re to finalnie skÅ‚adajÄ… siÄ™ na naszÄ… aplikacjÄ™. W tym poÅ›cie bÄ™dziemy chcieli przygotowaÄ‡ obraz z podstawowÄ… aplikacjÄ… zbudowanÄ… w Express.js.

Zanim jednak przejdziemy do Dockera pomyÅ›lmy co musimy zrobiÄ‡, aby taka aplikacja mogÅ‚a dziaÅ‚aÄ‡:

- Express.js jest frameworkiem dziaÅ‚ajÄ…cym w Node.js, wiÄ™c potrzebujemy tego wÅ‚aÅ›nie Å›rodowiska,
- gdy bÄ™dziemy posiadaÄ‡ juÅ¼ Node.js, bÄ™dziemy mogli skorzystaÄ‡ z npm (jest on instalowany wraz z Node.js), a wiÄ™c damy radÄ™ zainstalowaÄ‡ Express.js (`npm install ...`),
- majÄ…c Express.js, moÅ¼emy w koÅ„cu zaczÄ…Ä‡ pisaÄ‡ kod,
- napisany kod musimy uruchomiÄ‡ za pomocÄ… jakiegoÅ› skryptu,
- weryfikacja w przeglÄ…darce, czy nasza aplikacja jest dostÄ™pna pod wskazanym w kodzie portem.

Wiemy juÅ¼ jak uruchomilibyÅ›my takÄ… aplikacjÄ™ bez Dockera, sprÃ³bujmy teraz dokonaÄ‡ jej â€konteneryzacjiâ€.

## Dockerfile

ZdecydowanÄ… wiÄ™kszoÅ›Ä‡ z krokÃ³w wymienionych w poprzednim rozdziale wykonamy za pomocÄ… tzw. [Dockerfile](https://docs.docker.com/engine/reference/builder/). Jest to zwykÅ‚y plik tekstowy o nazwie `Dockerfile` (brak rozszerzeÅ„, sama nazwa), ktÃ³ry zawiera szereg instrukcji, dziÄ™ki ktÃ³rym damy radÄ™ stworzyÄ‡ w peÅ‚ni funkcjonalny obraz. Obraz ten bÄ™dzie zawieraÅ‚ wszystko, co jest nam potrzebne do uruchomienia opisanej aplikacji.

Dockerfile skÅ‚ada siÄ™ z par `instrukcja â¬…ï¸â¡ï¸ argumenty dla instrukcji`. Opisuje on dokÅ‚adnie, z jakich elementÃ³w powinno skÅ‚adaÄ‡ siÄ™ Å›rodowisko wykonawcze dla umieszczonej w obrazie aplikacji. Zobaczmy teraz, jak moÅ¼e wyglÄ…daÄ‡ przykÅ‚adowy prosty plik Dockerfile:

```dockerfile
# Obraz bazowy
FROM node:alpine

# Instalacja paczek
RUN npm i -g serve

# DomyÅ›lna komenda startowa
CMD ["serve", "--help"]
```

W pliku powyÅ¼szym widzimy trzy instrukcje â€“ `FROM`, `RUN` oraz `CMD`. Instrukcje te sÄ… rÃ³wnieÅ¼ wykonywane z przypisanymi im argumentami, odpowiednio â€“ `node:alpine`, `npm install` oraz `["npm", "start"]`. Przyjrzyjmy siÄ™ teraz tym trzem krokom nieco bliÅ¼ej.

## Obraz bazowy

Obraz bazowy moÅ¼emy traktowaÄ‡ jak swego rodzaju system operacyjny dla tworzonego przez nas obrazu. Jest to baza, do ktÃ³rej bÄ™dziemy dodawaÄ‡ kolejne aplikacje (np. biblioteki) oraz nasz wÅ‚asny kod. To od nas zaleÅ¼y, z jakiego punktu zaczniemy tworzenie naszego obrazu wÅ‚aÅ›nie poprzez okreÅ›lenie obrazu bazowego.

Jako obrazu bazowego moÅ¼emy uÅ¼yÄ‡ â€goÅ‚egoâ€ systemu operacyjnego, np. [Ubuntu](https://ubuntu.com/) lub [Alpine](https://alpinelinux.org/). W takim przypadku musimy samodzielnie zainstalowaÄ‡ wszystkie potrzebne nam narzÄ™dzia (np. Node.js). Lepszym rozwiÄ…zaniem moÅ¼e byÄ‡ skorzystanie z gotowego obrazu, ktÃ³ry to posiada juÅ¼ wiÄ™kszoÅ›Ä‡ tych narzÄ™dzie preinstalowanych. DziÄ™ki temu nasz plik Dockerfile bÄ™dzie duÅ¼o mniejszy i Å‚atwiejszy do zarzÄ…dzania. SkÄ…d tylko wziÄ…Ä‡ te obrazy? ğŸ¤”

NajÅ‚atwiejszym sposobem na wyszukanie obrazÃ³w bazowych jest [DockerHub](https://hub.docker.com/). Tam znajdziemy wiÄ™kszoÅ›Ä‡ obrazÃ³w, ktÃ³rych bÄ™dziemy mogli uÅ¼yÄ‡ jako punkt startowy do naszej pracy. Wspomniane powyÅ¼ej systemy operacyjne znajdziemy pod tym linkami: [Ubuntu](https://hub.docker.com/_/ubuntu), [Alpine](https://hub.docker.com/_/alpine), natomiast **Node.js** dostÄ™pny jest [tutaj](https://hub.docker.com/_/node). Gdy zajrzymy na tÄ™ stronÄ™, bÄ™dziemy mogli zauwaÅ¼yÄ‡, iÅ¼ wiÄ™kszoÅ›Ä‡ obrazÃ³w Node bazuje na systemie Alpine, a wiÄ™c twÃ³rcy tego obrazu postanowili skorzystaÄ‡ z obrazu Alpine, jako obrazu bazowego dla obrazu Node.

## Instalacje paczek

Wszystkie instrukcje `RUN` wykonywane sÄ… wewnÄ…trz wybranego przez nas obrazu bazowego. To tutaj moÅ¼emy np. zainstalowaÄ‡ dodatkowe narzÄ™dzia i dokonaÄ‡ ich konfiguracji. Argumenty tej instrukcji zaleÅ¼Ä… tylko i wyÅ‚Ä…czenie od uÅ¼ywanego przez nas systemu operacyjnego. GdybyÅ›my jako obraz bazowy wybrali Alpine, wtedy wywoÅ‚anie komendy `npm -i -g serve` pokazaÅ‚oby nam bÅ‚Ä…d, gdyÅ¼ domyÅ›lnie Alpine nie zna takiej skÅ‚adni. W takim wypadku w pierwszej kolejnoÅ›ci musielibyÅ›my zainstalowaÄ‡ Node.js:

```dockerfile
FROM alpine
RUN apk add --update nodejs npm
RUN npm i -g serve
# reszta pliku...
```

W naszym przykÅ‚adowym Dockerfile skorzystamy z menadÅ¼era `npm` i za jego pomocÄ… zainstalujemy paczkÄ™ [serve](https://www.npmjs.com/package/serve).

## DomyÅ›lna komenda startowa

Komenda ta zostanie automatycznie wywoÅ‚ana w momencie, gdy uruchomimy kontener. NajczÄ™Å›ciej bÄ™dzie to uruchomienie aplikacji. Warto tutaj pamiÄ™taÄ‡ o tym, iÅ¼ komendÄ™ oraz argumenty podajemy jako pojedyncze elementy tablicy. W naszym prostym przykÅ‚adzie uruchomimy jedynie komendÄ™ `serve --help`, ktÃ³ra to powinna wyÅ›wietliÄ‡ nam pomoc dla zainstalowanej wczeÅ›niej paczki z `npm`.

## Budowanie obrazu z pliku Dockerfile

Zbudowanie obrazu z pliku Dockerfile jest doÅ›Ä‡ prostym zadaniem i wymaga od nas jedynie wywoÅ‚ania komendy:
`docker build .` (naleÅ¼y zwrÃ³ciÄ‡ uwagÄ™ na to, Å¼e na samym koÅ„cu tej komendy podajemy kropkÄ™ `.`).

W wyniku wywoÅ‚ania powyÅ¼szej komendy na naszym przykÅ‚adowym pliku powinniÅ›my finalnie otrzymaÄ‡ nastÄ™pujÄ…cy wynik (przepraszam za ciemno-niebieskÄ… czcionkÄ™, ale mÃ³j wiersz poleceÅ„ mocno siÄ™ na niÄ… uparÅ‚ ğŸ™‚):

<img src={dockerBuild.src} />

Ostatnia linijka w wierszu poleceÅ„ ujawnia nam ID nowo stworzonego obrazu. Obraz ten moÅ¼emy teraz uruchomiÄ‡ za pomocÄ… znanej nam juÅ¼ komendy `docker run ID`:

<img src={dockerRun.src} />

Jak pamiÄ™tamy, w naszym pliku Dockerfile ustawiliÅ›my jako komendÄ™ startowÄ… wartoÅ›Ä‡ `serve --help`, a wiÄ™c wyÅ›wietlenie pomocy dla zainstalowanej wczeÅ›niej paczki (zainstalowaliÅ›my jÄ… za pomocÄ… instrukcji `RUN`). Widzimy teraz, iÅ¼ uruchomienie kontenera faktycznie pokazaÅ‚o nam pomoc dla paczki `serve`, a wiÄ™c **udaÅ‚o nam siÄ™ poprawnie zbudowaÄ‡ obraz** oraz stworzyÄ‡ z niego kontener ğŸ¥³.

W naszym prostym przykÅ‚adzie skorzystaliÅ›my jedynie z trzech najbardziej podstawowych instrukcji â€“ `FROM`, `RUN` oraz `CMD`. Jest to dobry punkt startowy, Å¼eby zapoznaÄ‡ siÄ™ z tworzeniem obrazÃ³w, jednak w Å›wiecie rzeczywistym tych instrukcji bÄ™dzie znacznie wiÄ™cej. PrzypomnÄ™ jeszcze raz, iÅ¼ wszystkie instrukcje znajdziemy w [oficjalnej dokumentacji Dockera](https://docs.docker.com/engine/reference/builder/).

## Dwa sÅ‚owa o budowaniu obrazu

Celem tej serii wpisÃ³w na temat Dockera jest jak najszybsze i jak najÅ‚atwiejsze zapoznanie czytelnika z Dockerem. Tym razem powiemy sobie dwa dodatkowe sÅ‚owa na temat tego, co dzieje siÄ™ â€za kulisamiâ€ podczas budowania obrazu. DziÄ™ki temu bÄ™dzie nam Å‚atwiej zrozumieÄ‡ dalszÄ… czÄ™Å›Ä‡ artykuÅ‚u.

KaÅ¼da z instrukcji znajdujÄ…cych siÄ™ w Dockerfile koÅ„czy swoje dziaÅ‚anie, tworzÄ…c â€tymczasowyâ€ obraz. Obraz ten nastÄ™pnie jest uÅ¼ywany niejako w roli â€obrazu bazowegoâ€ dla kolejnej instrukcji, ktÃ³ra to ponownie na samym koÅ„cu tworzy nowy â€tymczasowyâ€ obraz i podaje go dalej. W ten sposÃ³b kolejne obrazy sÄ… â€nadbudowywaneâ€ o zmiany wprowadzane przez kolejne instrukcje.

JednÄ… z rzeczy, ktÃ³ra sprawia, iÅ¼ Docker jest dzisiaj tak popularny, jest jego szybkoÅ›Ä‡ dziaÅ‚ania. JeÅ¼eli na swoim komputerze stworzyÅ‚eÅ›/stworzyÅ‚aÅ› juÅ¼ plik Dockerfile z przykÅ‚adu umieszczonego powyÅ¼ej i uruchomiÅ‚eÅ› po raz pierwszy komendÄ™ `docker build .`, budowanie obrazu trwaÅ‚o pewnie kilkanaÅ›cie sekund. SprÃ³buj wykonaÄ‡ teraz tÄ™ komendÄ™ jeszcze raz ğŸ™‚. Build teraz wykonaÅ‚ siÄ™ natychmiastowo. Dlaczego?

<img src={why.src} />

owiedzieliÅ›my juÅ¼ sobie, Å¼e podczas wykonywania kolejnych instrukcji Docker tworzy â€tymczasoweâ€ obrazy, ktÃ³re przekazuje kolejnym instrukcjom w Dockerfile. **Obrazy te zostajÄ… rÃ³wnieÅ¼ zachowane przez Dockera w pamiÄ™ci â€cacheâ€** i gdy tylko bÄ™dzie taka moÅ¼liwoÅ›Ä‡, obrazy te zostanÄ… uÅ¼yte ponownie. DziÄ™ki temu oszczÄ™dzamy czas, ktÃ³ry musielibyÅ›my poÅ›wiÄ™ciÄ‡ na ponowne ich budowanie. O tym, czy dana instrukcja zostaÅ‚a wykonana w caÅ‚oÅ›ci, czy zostaÅ‚ wykorzystany cache, dowiemy siÄ™, obserwujÄ…c terminal:

<img src={cached.src} />

Obrazy te jednak zostanÄ… uÅ¼yte tylko wtedy, gdy nie zmienimy niczego w pliku Dockerfile. Gdy taka zmiana nastÄ…pi, Docker bÄ™dzie musiaÅ‚ tworzyÄ‡ obrazy od poczÄ…tku. Dobra wiadomoÅ›Ä‡ jest taka, iÅ¼ czytajÄ…c plik Dockerfile â€od gÃ³ryâ€â¬‡, Docker bÄ™dzie uÅ¼ywaÅ‚ obrazÃ³w z cache tak dÅ‚ugo, aÅ¼ trafi na pierwszÄ… zmianÄ™ w pliku. Tak wiÄ™c, gdybyÅ›my w naszym przykÅ‚adzie umieÅ›cili nowÄ… komendÄ™ `RUN` w linii nr 4, wtedy wszystkie nastÄ™pujÄ…ce po niej instrukcje musiaÅ‚aby zostaÄ‡ przebudowane od zera. GdybyÅ›my jednak umieÅ›cili nowÄ… instrukcjÄ™ w linii nr 6, wtedy instrukcja z linii nr 5 mogÅ‚aby skorzystaÄ‡ z cache.

JeÅ¼eli wiÄ™c chcemy jak najrzadziej dokonywaÄ‡ peÅ‚nych buildÃ³w pamiÄ™tajmy, aby nowe instrukcje umieszczaÄ‡ moÅ¼liwie â€niskoâ€ w pliku Dockerfile.

## Aplikacja Express.js

Skoro wiemy juÅ¼, czym jest Dockerfile i jak za jego pomocÄ… tworzyÄ‡ obrazy, stwÃ³rzmy teraz wspomnianÄ… juÅ¼ na poczÄ…tku aplikacjÄ™. Projekt bÄ™dzie maÅ‚y, poniewaÅ¼ nie o sam kod tutaj chodzi, ale o jego poprawne â€dockeryzacjÄ™â€.

Kroki, ktÃ³re za chwilÄ™ wykonamy bÄ™dÄ… wyglÄ…daÅ‚y nasÄ™pujÄ…co:

- Stworzenie aplikacji webowej przy uÅ¼yciu Node.js oraz Express.js.
- Stworzenie pliku Dockerfile.
- Zbudowanie obrazu z pliku.
- Uruchomienie obrazu jako kontener.
- Przetestowanie aplikacji w przeglÄ…darce.

### Aplikacja

Sama aplikacja jest maksymalnie prosta i myÅ›lÄ™, Å¼e jej zrozumienie nie powinno sprawiÄ‡ nikomu problemÃ³w. Pliki ÅºrÃ³dÅ‚owe znajdziemy tutaj: [Web App Gist](https://gist.github.com/kamiljozwik/b8152f9f7f74b697d2a2af9e34e01744).

### Dockerfile

PrzejdÅºmy do meritum tego przykÅ‚adu, czyli pliku Dockerfile. Plik ten umieszczamy w gÅ‚Ã³wnym katalogu projektu. AplikacjÄ™ tworzymy w Å›rodowisku Node.js, a wiÄ™c skorzystamy ze znanego juÅ¼ nam bazowego obrazu â€“ Node. MajÄ…c pliki `package.json` oraz `index.js`, musimy w pierwszej kolejnoÅ›ci zainstalowaÄ‡ sobie wszystkie zaleÅ¼noÅ›ci za pomocÄ… `npm install`, a nastÄ™pnie uruchomiÄ‡ skrypt uruchamiajÄ…cy naszÄ… aplikacjÄ™ â€“ `npm start`. Wydaje siÄ™ wiÄ™c, Å¼e Dockerfile bÄ™dzie dosyÄ‡ prosty:

```dockerfile
# Obraz bazowy
FROM node:alpine

# Instalacja paczek
RUN npm install

# Komenda startowa
CMD ["npm", "start"]`
```

JeÅ¼eli juÅ¼ zauwaÅ¼yÅ‚eÅ›, Å¼e z takim plikiem Dockerfile nie uruchomimy poprawnie naszej aplikacji, to znaczy, Å¼e dokÅ‚adnie przeczytaÅ‚eÅ› dwa poprzednie wpisy ğŸ’ª. Instrukcje `RUN` oraz `CMD` zostanÄ… wykonane na plikach znajdujÄ…cych siÄ™ wewnÄ…trz obrazu Node. Nie ma tam jeszcze napisanego przez nas kodu. Musimy wiÄ™c w jakiÅ› sposÃ³b umieÅ›ciÄ‡ go w nowo tworzonym obrazie.

Kopiowanie plikÃ³w wykonamy za pomocÄ… prostej komendy `COPY`. Dobrze jest w tym momencie okreÅ›liÄ‡ rÃ³wnieÅ¼ katalog roboczy. DziÄ™ki temu wszystkie przyszÅ‚e komendy bÄ™dÄ… wykonywane wÅ‚aÅ›nie z tego poziomu. Te katalog rÃ³wnieÅ¼ bÄ™dzie wybrany w przypadku wykonywania komend z â€kropkÄ…â€ `.`, gdzie kropka wÅ‚aÅ›nie najczÄ™Å›ciej oznacza nasz aktualny katalog roboczy. W pliku Dockerfile bÄ™dzie wyglÄ…daÅ‚o to nastÄ™pujÄ…co:

```dockerfile
# Obraz bazowy
FROM node:alpine

# Ustawiamy katalog roboczy w obrazie
WORKDIR /usr/nodeWebApp

# Kopiujemy pliki z aktualnego katalogu (nasz kod) do katalogu roboczego
COPY ./ ./

# Instalacja paczek (wykonana w katalogu roboczym czyli "/usr/nodeWebApp")
RUN npm install

# Komenda startowa (wykonana w katalogu roboczym czyli "/usr/nodeWebApp")
CMD ["npm", "start"]
```

GdybyÅ›my w powyÅ¼szym przykÅ‚adzie nie ustawili katalogu roboczego za pomocÄ… instrukcji `WORKDIR`, wtedy pliki zostaÅ‚yby skopiowane do nadrzÄ™dnego katalogu systemu operacyjnego, czyli tak gdzie w przypadku Linuxa znajdujÄ… siÄ™ foldery `bin`, `etc`, `lib` itp.

<Info title="Docker w VS Code">
  [VS Code](https://code.visualstudio.com/) posiada rozszerzenie, dziÄ™ki ktÃ³remu
  moÅ¼emy uÅ‚atwiÄ‡ sobie znacznie tworzenie plikÃ³w Dockerfile:
  [https://marketplace.visualstudio.com/items?itemName=ms-azuretools.vscode-docker](https://marketplace.visualstudio.com/items?itemName=ms-azuretools.vscode-docker)
</Info>

## Budowa obrazu i uruchomienie kontenera

Posiadamy teraz juÅ¼ poprawny plik Dockerfile, sprÃ³bujmy wiÄ™c zbudowaÄ‡ obraz i uruchomiÄ‡ na jego podstawie kontener. Wykonujemy znanÄ… nam juÅ¼ komendÄ™ `docker build .` (pamiÄ™tamy o kropce na samym koÅ„cu):

<img src={node.src} />

MajÄ…c obraz, moÅ¼emy teraz zbudowaÄ‡ nowy kontener, podajÄ…c kilka pierwszych znakÃ³w ID (np. `bcb3d44`). Jednak ciÄ…gÅ‚e kopiowanie i wklejanie ID jest doÅ›Ä‡â€¦ nudne, moÅ¼emy nadaÄ‡ naszemu obrazowi nazwÄ™. W nomenklaturze Dockera â€“ [tagujemy obraz](https://docs.docker.com/engine/reference/commandline/tag/). MoÅ¼emy wykonaÄ‡ to teraz na stworzonym juÅ¼ obrazie za pomocÄ… komendy `docker tag Id Name`, czyli w naszym przykÅ‚adzie `docker tag bcb3d44 frontstack/webapp`.

NazwÄ™ takÄ… moÅ¼emy nadaÄ‡ rÃ³wnieÅ¼ podczas budowania obrazu, uÅ¼ywajÄ…c flagi `-t Name`. Komenda ta bÄ™dzie wtedy wyglÄ…daÅ‚a nastÄ™pujÄ…co: `docker build -t frontstack/nodeapp:latest`. Widzimy tutaj dodatkowy czÅ‚on `:latest`. De facto to jest wÅ‚aÅ›ciwy â€tagâ€ obrazu. Umieszczamy go po dwukropku `:` i jeÅ¼eli nie ustawimy go samodzielnie, to zostanie mu przypisana domyÅ›lna wartoÅ›Ä‡ `latest`. Wszystko to, co znajduje siÄ™ przed dwukropkiem, jest nazwÄ… obrazu. Wykonajmy teraz build obrazu z flagÄ… `-t frontstack/nodeapp:latest`:

<img src={buildTag.src} />

Aby odpoczÄ…Ä‡ trochÄ™ od wiersza poleceÅ„, nasze dwa nowo zbudowane obrazy moÅ¼emy podejrzeÄ‡ za pomocÄ… Docker Desktop:

<img src={desktop.src} />

ZostaÅ‚o nam juÅ¼ teraz tylko uruchomiÄ‡ jeden ze zbudowanych obrazÃ³w za pomocÄ… `docker run Name`.

<img src={nodeApp.src} />

## Testowanie w przeglÄ…darce

Czy teraz nasza praca jest juÅ¼ skoÅ„czona? OczywiÅ›cie, Å¼e nie ğŸ˜‰. PamiÄ™tajmy, Å¼e kontenery sÄ… caÅ‚kowicie odizolowane od reszty systemu operacyjnego dziaÅ‚ajÄ…cego na naszym komputerze. Dotyczy to rÃ³wnieÅ¼ sieci. JeÅ¼eli teraz sprÃ³bujemy odwiedziÄ‡ w przeglÄ…darce adres `localhost:8080`, otrzymamy informacjÄ™, iÅ¼ ta witryna jest nieosiÄ…galna. W celu przekierowania ruchu z naszego systemu do wnÄ™trza kontenera musimy odpowiednio ustawiÄ‡ przekierowania portÃ³w. W tym celu posÅ‚uÅ¼ymy siÄ™ flagÄ… `-p IncomingPort:ContainerPort`. Flaga ta przyjmuje dwa numery portÃ³w rozdzielone dwukropkiem :. Pierwszym portem jest port na naszym lokalnym systemie, drugim natomiast jest port wewnÄ…trz kontenera. Nasza aplikacja uruchomiona jest wewnÄ…trz kontenera i nasÅ‚uchuje na porcie `:8080`, wiÄ™c ten port bÄ™dzie podany jako drugi. Pierwszym portem jest port, ktÃ³ry podamy w przeglÄ…darce podczas wykonywania zapytania. Nie musi to byÄ‡ ten sam port co w kontenerze.

W takim przypadku uruchamiajÄ…c kontener za pomocÄ… `docker run -p 8050:8080`, nasza aplikacja bÄ™dzie dostÄ™pna dla nas pod adresem `localhost:8050`.

<img src={hello.src} />

## Zmiany w kodzie

ArtykuÅ‚ ten zakoÅ„czymy omÃ³wieniem, w jaki sposÃ³b moÅ¼emy teraz dokonywaÄ‡ zmian w kodzie i widzieÄ‡ te zmiany w przeglÄ…darce. W tym momencie aplikacja jest uruchomiona w kontenerze i kontener ten zostaÅ‚ uruchomiony z obrazu zawierajÄ…cego nasz kod. Wszelkie zmiany, ktÃ³re teraz wykonamy w kodzie, oczywiÅ›cie nie bÄ™dÄ… widoczne od razu w przeglÄ…darce. W najprostszym podejÅ›ciu, po zakoÅ„czeniu kodowania musimy zbudowaÄ‡ nowy obraz, do ktÃ³rego to zostanÄ… przesÅ‚ane nowe pliki i nastÄ™pnie obraz ten uruchomiÄ‡ jako kontener.

Podczas builda Docker zauwaÅ¼y w plikach i wykona od nowa instrukcjÄ™ `COPY` (nie skorzysta z cache) oraz wszystkie instrukcje wystÄ™pujÄ…ce po niej. Dla nas oznacza to, iÅ¼ zmiana w pliku `index.js` spowoduje, iÅ¼ ponownie zostanie uruchomiona komenda `npm install`. Nie jest to najlepsze rozwiÄ…zanie, poniewaÅ¼ stracimy czas na instalowanie paczek, mimo iÅ¼ nie dokonaliÅ›my Å¼adnych zmian w `package.json`.

MoÅ¼emy temu zaradziÄ‡, wprowadzajÄ…c delikatne zmiany w pliku Dockerfile:

```dockerfile
# Obraz bazowy
FROM node:alpine

# Ustawiamy katalog roboczy w obrazie
WORKDIR /usr/nodeWebApp

# Kopiujemy tylko plik package.json
COPY ./package.json ./

# Instalacja paczek
RUN npm install

# Kopiujemy pliki z aktualnego katalogu (nasz kod) do katalogu roboczego
COPY ./ ./

# Komenda startowa
CMD ["npm", "start"]
```

PamiÄ™tacie jeszcze, kiedy Docker skorzysta z cache, a kiedy nie? ğŸ™‚ Zmiana, ktÃ³rÄ… teraz wprowadziliÅ›my, spowoduje, iÅ¼ Docker wykona instrukcjÄ™ `RUN` tylko wtedy, gdy nastÄ…pi zmiana w pliku `package.json`. To tam trafiajÄ… wszystkie nowe zaleÅ¼noÅ›ci. JeÅ¼eli natomiast zmiana zostanie wykonana tylko w plikach ÅºrÃ³dÅ‚owych z kodem, wtedy podczas budowania obrazu, zamiast wykonania od nowa instrukcji `RUN`, zostanie uÅ¼yty cache âš¡.

## .dockerignore

Poza plikiem `Dockerfile` moÅ¼emy stworzyÄ‡ rÃ³wnieÅ¼ plik `.dockerignore`. JeÅ¼eli jesteÅ› zaznajomiony/zaznajomiona z gitem, to pewnie wiesz, jaka bÄ™dzie jego rola. To tutaj moÅ¼emy okreÅ›liÄ‡ ktÃ³re pliki nie powinny byÄ‡ kopiowane do obrazu pliku. W przypadku aplikacji tworzonych w Node.js bÄ™dziemy chcieli uniknÄ…Ä‡ przesÅ‚ania folderu `node_modules`.

```dockerfile title=".dockerignore"
node_modules
```

Wszystkie zaleÅ¼noÅ›ci zainstalujemy sobie podczas uruchamiania aplikacji, dziÄ™ki temu obraz bÄ™dzie duÅ¼o mniejszy. Tak przygotowany obraz moÅ¼emy umieÅ›ciÄ‡ np. na naszym koncie [DockerHub](https://hub.docker.com/) lub [AWS ECR](https://aws.amazon.com/ecr/) i udostÄ™pniÄ‡ go szerszej publicznoÅ›ci.

## Podsumowanie

Mam nadziejÄ™, Å¼e po tym wpisie Docker i zwiÄ…zane z nim tematy stanÄ… jeszcze bardziej zrozumiaÅ‚e. Wiemy juÅ¼ teraz jak samodzielnie tworzyÄ‡ obrazy i uruchamiaÄ‡ z nich kontenery. Zbudowane przez nas obrazy moÅ¼emy nastÄ™pnie uruchamiaÄ‡ wszÄ™dzie tam, gdzie bÄ™dzie zainstalowany Docker. Ten sposÃ³b uruchamiana aplikacji zapewnia, iÅ¼ aplikacja bÄ™dzie zachowywaÅ‚a siÄ™ na kaÅ¼dym serwerze dokÅ‚adnie tak samo, a stwierdzenie â€dziwne, u mnie dziaÅ‚aâ€ przestanie juÅ¼ byÄ‡ wytÅ‚umaczeniem ğŸ˜‰
